#lang racket/base
(require "../monad.rkt"
         "../formal.rkt"
         "../rewrite.rkt"
         "../tools.rkt"
         "../types.rkt"
         rackunit)

(test-case
 "Monad List"
 (define-formal f g)
 (using-monad List)
 (check-equal? (return 'x) '(x))
 (check-equal? (bind '(x y z) >>= return) '(x y z))
 (check-equal? (bind '() >>= return) '())
 (check-equal? (bind (return 'x) >>= (lift f)) '((f x)))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= (lift f))))
 (check-equal? (bind '() >>= (lift f)) '())
 (check-equal? (bind (return 'x) >>= (lift f) >>= (lift g)) '((g (f x))))
 (check-equal? (bind '() >>= (lift f) >>= (lift g)) '())
 (check-equal? (bind (return 'x) >>= (/. 'x --> '()) >>= (lift g)) '())
 (check-equal? (bind (return 'x) >>= (guardf (const #t)) >>= (lift g)) '((g x)))
 (check-equal? (bind (return 'x) >>= (guardf (const #f)) >>= (lift g)) '())
 (check-equal? (bind (return 3) >>= (guardf odd?) >>= (lift g)) '((g 3)))
 (check-equal? (bind (return 3) >>= (guardf even?) >>= (lift g)) '())
 (check-equal? (do [x <-: 'x] (guard #t) (return (g x))) '((g x)))
 (check-equal? (do [x <-: 3] (guard #f) (return (g x))) '())
 (check-equal? (collect (g y) [x <-: 'x] #t [y <-: (f x)]) '((g (f x))))
 (check-equal? (collect (g y) [x <-: 'x] #f [y <-: (f x)]) '())
 (check-equal? ((compose/m (lift f) (lift g)) 'x) '((f (g x))))
 (check-equal? (map (compose/m (lift f) (/. 'a --> '() x --> (list x))) '(a b)) '(() ((f b))))
 (check-equal? (fold/m (lift f) 'x '(a b c)) '((f c (f b (f a x)))))
 (check-equal? (filter/m (lift (const #t)) '(a b c)) '((a b c)))
 (check-equal? (filter/m (lift (const #f)) '(a b c)) '(()))
 (check-equal? (filter/m (lift (/. 'b --> #f)) '(a b c d)) '((a c d)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5)) '((1 3 5)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5 6)) '((1 3 5)))
 (check-equal? (filter/m (λ (x) (list #t #f)) '(1 2 3)) '((1 2 3) (1 2) (1 3) (1) (2 3) (2) (3) ()))
 (check-equal? (map/m (lift f) '(a b c)) '(((f a) (f b) (f c))))
 (check-equal? (map/m return '(a b c)) '((a b c)))
 (check-equal? (seq/m '((a) (b) (c))) '((a b c)))
 (check-equal? (seq/m '((a) () (c))) '())
 (check-equal? (sum/m '((a) (b) (c))) '(a b c))
 (check-equal? (sum/m '((a) () (c))) '(a c))
 (check-equal? (lift/m f '(x)) '((f x)))
 (check-equal? (lift/m f '(x) '(y)) '((f x y)))
 (check-equal? (lift/m f '(x) '(y) '()) '())
 (check-equal? (lift/m f '(x y) '(a b)) '((f x a) (f x b) (f y a) (f y b)))
 (check-equal? (lift/m f '(x y) '(a)) '((f x a) (f y a)))
 (check-equal? (do [1 <- '(1 2 3 2 1 2 3)] (return 'y)) '(y y))
 (check-equal? (collect x [(? odd? x) <- '(1 2 3 2 1 2 3)]) '(1 3 1 3))
 (check-equal? (collect (cons x y) [(list x y) <- (zip '(a b c) 40)])
               '((a . 0) (b . 1) (c . 2))))

(require "../examples/List-comprehension.rkt")
(require "../examples/nondeterministic.rkt")

(test-case
 "Monad Set"
 (define-formal f g)
 (using-monad Set)
 (check-equal? (return 'x) (set 'x))
 (check-equal? (bind '(x y z) >>= return) (set 'x 'y 'z))
 (check-equal? (bind '() >>= return) (set))
 (check-equal? (bind (return 'x) >>= (lift f)) (set (f 'x)))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= (lift f))))
 (check-exn exn:fail:contract? (λ () (bind 'x >>= f)))
 (check-equal? (bind '() >>= (lift f)) (set))
 (check-equal? (bind (return 'x) >>= (lift f) >>= (lift g)) (set (g (f 'x))))
 (check-equal? (bind '() >>= (lift f) >>= (lift g)) (set))
 (check-equal? (bind (return 'x) >>= (/. 'x --> (set)) >>= (lift g)) (set))
 (check-equal? (bind (return 'x) >>= (guardf (const #t)) >>= (lift g)) (set (g 'x)))
 (check-equal? (bind (return 'x) >>= (guardf (const #f)) >>= (lift g)) (set))
 (check-equal? (bind (return 3) >>= (guardf odd?) >>= (lift g)) (set (g 3)))
 (check-equal? (bind (return 3) >>= (guardf even?) >>= (lift g)) (set))
 (check-equal? (do [x <-: 'x] (guard #t) (return (g x))) (set (g 'x)))
 (check-equal? (do [x <-: 3] (guard #f) (return (g x))) (set))
 (check-equal? (collect (g y) [x <-: 'x] #t [y <-: (f x)]) (set (g (f 'x))))
 (check-equal? (collect (g y) [x <-: 'x] #f [y <-: (f x)]) (set))
 (check-equal? ((compose/m (lift f) (lift g)) 'x) (set (f (g 'x))))
 (check-equal? (map (compose/m (lift f) (/. 'a --> (set) x --> (set x))) '(a b)) (list (set) (set (f 'b))))
 (check-equal? (fold/m (lift f) 'x '(a b c)) (set (f 'c (f 'b (f 'a 'x)))))
 (check-equal? (filter/m (lift (const #t)) '(a b c)) (set '(a b c)))
 (check-equal? (filter/m (lift (const #f)) '(a b c)) (set '()))
 (check-equal? (filter/m (lift (/. 'b --> #f)) '(a b c d)) (set '(a c d)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5)) (set '(1 3 5)))
 (check-equal? (filter/m (lift odd?) '(1 2 3 4 5 6)) (set '(1 3 5)))
 (check-equal? (filter/m (λ (x) (set #t #f)) '(1 2 3)) (set '(1 2 3) '(1 2) '(1 3) '(1) '(2 3) '(2) '(3) '()))
 (check-equal? (map/m (lift f) '(a b c)) (set '((f a) (f b) (f c))))
 (check-equal? (map/m return '(a b c)) (set '(a b c)))
 (check-equal? (seq/m (list (set 'a) (set 'b) (set 'c))) (set '(a b c)))
 (check-equal? (seq/m (list (set 'a) (set) (set 'c))) (set))
 (check-equal? (sum/m (list (set 'a) (set 'b) (set 'c))) (set 'a 'b 'c))
 (check-equal? (sum/m (list (set 'a) (set 'b) (set 'c) (set 'a 'd))) (set 'a 'b 'c 'd))
 (check-equal? (sum/m (list (set 'a) (set) (set 'c))) (set 'a 'c))
 (check-equal? (lift/m f '(x)) (set (f 'x)))
 (check-equal? (lift/m f '(x) '(y)) (set (f 'x 'y)))
 (check-equal? (lift/m f '(x) '(y) '()) (set))
 (check-equal? (lift/m f (set 'x 'y) (set 'a 'b)) (set '(f x a) '(f x b) '(f y a) '(f y b)))
 (check-equal? (lift/m f (set 'x 'y) (set 'a)) (set '(f x a) '(f y a)))
 (check-equal? (do [1 <- '(1 2 3 2 1 2 3)] (return 'y)) (set 'y))
 (check-equal? (collect x [(? odd? x) <- '(1 2 3 2 1 2 3)]) (set 1 3))
 (check-equal? (collect (cons x y) [(list x y) <- (zip '(a b c) 40)])
               (set '(a . 0) '(b . 1) '(c . 2))))

