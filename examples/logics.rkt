#lang formica
(require rackunit)
;; =====================================================================
;; разложение логических выражений в дизъюнктивную нормальную форму
;; =====================================================================


(define-formal && || !)
;; =====================================================================
;; перевод инфиксной записи в префиксную
;; =====================================================================
(define infix->prefix
  (rewrite-all-repeated
   `(,a __1  <=> ,b __1) --> (&& `(,a ==> ,b) `(,b ==> ,a)) 
   `(,a __1  ==>  ,b __1) --> (|| b (! a))       
   `(,a __1  ||  ,b __1) --> (|| a b)         
   `(,a __1  &&  ,b __1) --> (&& a b)                 
   `(,a) -->  a))

;; =====================================================================
;; упрощение выражений в префиксной записи
;; =====================================================================
(define simplify
  (rewrite-all-repeated
   ; исключение лишних скобок
   `(,a) --> a 
   
   ; вырожденные случаи
   (|| a)  -->  a 
   (||)    --> 'F 
   (&& a)  -->  a 
   (&&)    --> 'T 
   
   ; свойства отрицания
   (! (! a))  -->  a
   (! 'F)     --> 'T
   (! 'T)     --> 'F
   
   ; свойства конъюнкции
   (&& _ ___ 'F _ ___)            --> 'F                   
   (&& x ___ 'T y ___)            --> `(&& ,@x ,@y)        
   (&& x ___ A y ___ A z ___)     --> `(&& ,@x ,A ,@y ,@z) 
   (&& _ ___ A _ ___ (! A) _ ___) --> 'F                   
   
   ; свойства дизъюнкции
   (|| _ ___ 'T _ ___)            --> 'T
   (|| x ___ 'F y ___)             --> `(|| ,@x ,@y)
   (|| x ___ A y ___ A z ___)     --> `(|| ,@x ,A ,@y ,@z)
   (|| _ ___ A _ ___ (! A) _ ___) --> 'T
   
   
   ; законы ассоциативности
   (&& a ___ (&& b __1) c ___) --> `(&& ,@a ,@b ,@c) 
   (|| a ___ (|| b __1) c ___) --> `(|| ,@a ,@b ,@c)
   
   ; группировка дизъюнктов
   (|| x ___ A y ___ (&& _ ___ A _ ___) z ___)     --> `(|| ,@x ,A ,@y ,@z)
   (|| x ___ A y ___ (&& p ___ (! A) q ___) z ___) --> `(|| ,@x ,A ,@y (&& ,@p ,@q) ,@z) 
   (|| x ___ (! A) y ___ (&& p ___ A q ___) z ___) --> `(|| ,@x (! ,A) ,@y (&& ,@p ,@q) ,@z) 
   
   ; группировка конъюнктов
   (&& x ___ A y ___ (|| _ ___ A _ ___) z ___) --> `(&& ,@x ,A ,@y ,@z) 
   (&& x ___ A y ___ (|| p ___ (! A) q ___) z ___) --> `(&& ,@x ,A ,@y (|| ,@p ,@q) ,@z) 
   (&& x ___ (! A) y ___ (|| p ___ A q ___) z ___) --> `(&& ,@x (! ,A) ,@y (|| ,@p ,@q) ,@z) 
   
   ; сортировка элементов в выражении
   (cons op x) -->  (cons op (sort (map simplify x) ordered?))))

;; =====================================================================
;; перевод в дизъюнктивную нормальную форму
;; =====================================================================
(define DNF
  (compose simplify
           (rewrite-all-repeated
            ; законы де Моргана
            (! (|| a b __1))  --> (&& (! a) (! `(|| ,@b))) 
            (! (&& a b __1))  --> (|| (! a) (! `(&& ,@b))) 
            
            ; закон дистрибутивности
            (&& a ___ (|| b bb __1) c ___) --> `(|| (&& ,@a ,b ,@c) 
                                                    (&& ,@a (|| ,@bb) ,@c)) 
            
            ; повторная обработка выражений
            (cons op x) -->  (cons op (map DNF x)))))

;; =====================================================================
;; перевод в конъюнктивную нормальную форму
;; =====================================================================
(define CNF
  (compose simplify
           (rewrite-all-repeated
            ; законы де Моргана
            (! (|| a b __1))  --> (&& (! a) (! `(|| ,@b))) 
            (! (&& a b __1))  --> (|| (! a) (! `(&& ,@b))) 
            
            ; закон дистрибутивности
            (|| a ___ (&& b bb __1) c ___) --> `(&& (|| ,@a ,b ,@c) 
                                                    (|| ,@a (&& ,@bb) ,@c)) 
            
            ; повторная обработка выражений
            (cons op x) --> (cons op (map CNF x)))))

(define expand (compose DNF CNF infix->prefix))

;; =====================================================================
;; Примеры использования
;; =====================================================================
(test-case
 "rewrite: logics."
 (check-equal? (expand '((A || B) && C))  '(|| (&& A C) (&& B C)))
 (check-equal? (expand '((B || A) && (A || ! B)))   'A)
 (check-equal? (expand '((A || B) && B))           'B)
 
 (check-equal? (expand '((A ==> B) && A))    '(&& A B))
 (check-equal? (expand '(A ==> ! A))         '(! A))
 
 ;; примеры доказательства некоторых тавтологий
 
 (check-equal? (expand '(A || ! A))  'T)
 ;"третьего не дано"
 
 
 (check-equal? (expand '((A ==> B) <=> (! B ==> ! A)))  'T)
 ;"закон контрапозиции"
 
 
 (check-equal? (expand '((! A ==> B) && (! A ==> ! B) ==> A)) 'T)
 ;"принцип доказательства от противного"
 
 
 (check-equal? (expand '((человек ==> смертен) && (Сократ ==> человек) ==> (Сократ ==> смертен))) 'T)
 ;"силлогизм"
 
 
 (check-equal? (expand '((A || B) && (A ==> C) && (B ==> C) ==> C))  'T)
 ;"принцип доказательства методом полного перебора"
 
 
 (check-equal? (expand '(((P ==> Q) ==> P) ==> P)) 'T)
 ;"Закон Пирса"
 
 
 (check-equal? (expand '((p || ! r) && s ==> (r && s ==> (p && q) || p)))  'T)
 
 
 (check-equal? (expand '((A && B ==>  C) <=> (A ==> (B ==> C))||(B ==> (A ==> C)))) 'T)
 
 (check-equal? (expand '((A && B) ==> (A || B)))   'T)
 
 
 (check-equal? (expand '(((A <=> B) <=> C) <=> (A <=> (B <=> C))))  'T)
 
 
 (check-equal? (expand '(((A || B ==> A || C) <=> (A || (B ==> C)))))  'T))