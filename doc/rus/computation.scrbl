#lang scribble/doc

@(require (for-label formica))

@(require
  scribble/manual
  scribble/eval)

@(define formica-eval
   (let ([sandbox (make-base-eval)])
     (sandbox '(require formica))
     sandbox))

@title[#:tag "computation"]{Модель вычислений}

В этом разделе описывается модель вычислений, которой следует интерпретатор Formica.

@local-table-of-contents[]

@section[#:tag "fuctions"]{Функции}

Функции являются объектом первого класса.

Formica реализует строгие вычисления в аппликативном порядке, с возможностью организации отложенных вычислений и мемоизации.

Ниже приводится алгоритм вычисления произвольного функционального выражения:

@itemize{
  @item{Если выражение является атомом, возвращается связанное с ним значение.}
  @item{Если выражение представляет аппликацию функции:
    @itemize{
    @item{Сначала по очереди, следуя этому же алгоритму, вычисляются все элементы выражения.}
    @item{Вычисленные элементы, начиная со второго, подставляются в первый элемент, 
          как аргументы функции, после чего она вычисляется.}}}}

@section[#:tag "curring"]{Частичное применение функций}

Одним из отличий диалекта Formica от языка Racket является упрощённый синтаксис для каррирования и частичного применения функций.

@elemtag["t:curry"]{@emph{Каррирование}} --- преобразование мультиарной функции в последовательность
замыканий унарных функций.

@centered[@racket[(f _x _y) ==> (λ (x) (λ (y) (f x y)))]]

Например,  функция @racket[cons], конструирующая @elemref["t:pair"]{пару}, должна принимать два аргумента:
@interaction[#:eval formica-eval
  (cons 1 2)]


Мы можем её каррировать, так что она превращается в последовательность
замыканий унарных функций:
@interaction[#:eval formica-eval
  (cons)
  ((cons) 1)
  (((cons) 1) 2)]

@elemtag["t:partial"]{@emph{Частичное применение}} --- фиксация части формальных аргументов функции.

Пример:
@interaction[#:eval formica-eval
  (cons 1)
  ((cons 1) 2)]
Здесь в выражении @racket[(cons 1)] был зафиксирован первый аргумент 
бинарной функции @racket[cons]. Результатом этого является функция
от одного аргумента

Таким образом, можно создать функцию, прибавляющую единицу к своему аргументу:
@interaction[#:eval formica-eval
  (define inc (+ 1))
  (inc 3)
  ((+ 1) 3)
  (map (+ 1) '(1 2 3))] 

В общем случае, каррирование и частичное применение осуществляется с помощью
функций @racket[curry] и @racket[curryr].
Например, функция, вычитающая аргумент из единицы, может быть создана так:
@interaction[#:eval formica-eval
  (define 1- (curry - 1))
  (1- 3)
  (map (curry - 1) '(1 2 3))] 
Нам потребовалось использовать @racket[curry], поскольку функция @racket[-],
будучи применённой к одному аргументу, меняет его знак:
@interaction[#:eval formica-eval
  (- 1)
  (- -4)]

Если нужно создать функцию, вычитающую единицу из своего аргумента, 
потребуется функция  @racket[curryr], фиксирующая аргументы функции справа:
@interaction[#:eval formica-eval
  (define dec (curryr - 1))
  (dec 3)
  (map (curryr - 1) '(1 2 3))] 
                              
Упрощённый синтаксис для частичного применения функций может несколько замедлить 
работу программы. В случае, если скорость выполнения программы играет существенную роль,
можно загрузить язык Formica без упрощённого синтаксиса с помощью директивы
@para[@tt{#lang formica/regular-app}] в заголовке файла.

@section[#:tag "form"]{Синтаксические формы}

@elemtag["t:form"]{@emph{Синтаксической формой}} или @emph{макросом}, называется выражение, 
преобразуемое синтаксически до его вычисления. 
Формы позволяют, при необходимости, нарушать аппликативный порядок вычислений.

Например, синтаксической формой является оператор ветвления @racket[if], который
не вычисляет свои аргументы до того, как будет сделан выбор:
@interaction[#:eval formica-eval
  (if #t (display 'true) (display 'false))
  (if #f (display 'true) (display 'false))]

Если бы мы определили  @racket[if], как функцию, сначала были бы вычислены обе ветви, 
а потом был бы сделан выбор: 
@interaction[#:eval formica-eval
  (define (if* p x y)
    (if p x y))
  (if* #t (display 'true) (display 'false))
  (if* #t (display 'true) (display 'false))]

Простые синтаксические формы определяются с помощью @racket[define-syntax-rule].

@include-section["control.scrbl"]