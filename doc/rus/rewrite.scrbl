#lang scribble/doc

@(require (for-label formica))

@(require
  scribble/manual
  scribble/eval)

@(define formica-eval
   (let ([sandbox (make-base-eval)])
     (sandbox '(require formica))
     sandbox))

@declare-exporting[formica]

@title[#:tag "rewrite"]{Подстановки}

@section[#:tag-prefix "rewrite"]{Обычные подстановки}

@elemtag["t:rewrite"]{@emph{Подстановкой}} будем называть набор правил переписывания, которые применяются к S-выражению 
или его частям.


@defform/subs[#:literals (--> => ?)(rewrite rule-spec ...) 
([rule-spec (pat ... --> expr) 
            (pat ... --> (=> id) expr) 
            (pat ... --> (? guard) expr)])]
Преобразуется в функцию, применяющую по очереди правила @racket[rule-spec] для 
преобразования переданных ей аргументов. Если ни одно из правил не может быть применено, 
аргументы возвращаются без изменений.

@racket[_pat] --- произвольный @elemref["t:patt"]{шаблон}. 
Последовательность шаблонов соответствует последовательности аргументов, 
к которым применяется подстановка.

@racket[_expr] --- произвольное выражение. 

Примеры:
@def+int[#:eval formica-eval
 (define r 
   (rewrite 3 --> 4
            2 --> 3))
 (r 3)
 (r 2)
 (r 42)]
@def+int[#:eval formica-eval
 (define f 
   (rewrite x --> (* x x) 
            x y --> (* x y)))
 (f 4)
 (f 4 5)]

Если ни один из шаблонов не соответствует входным аргументам, они возвращаются в виде списка.

Необязательная форма @racket[(? _guard)] между образцом и 
выражением @racket[_expr] служит для определения образцов 
с охраной. Выражение @racket[_guard] вычисляется в контексте 
связываний, задаваемых образцом. Если оно равно @racket[#f] 
продолжается процесс сопоставления, как если бы аргументы не 
сопоставились с образцом. В противном случае, применяется соответствующее образцу правило. 


@defform[(rewrite-all rule-spec ...)]{
Преобразуется в функцию, которая, будучи применённой к списочной структуре, 
применяет подстановки, заданные @racket[rule-spec], ко всем частям списка. 
Если ни одно из правил не может быть применено, выражение возвращается без изменений.}

@defform[(/. rule-spec ...)]{Сокращённая запись формы @racket[rewrite-all].}

Примеры:
@interaction[#:eval formica-eval
                    ((/. 'a --> 'x) '(a b a d a))
                    ((/. 'a --> 'x) '(a (b (a) d) a))
                    ((/. 'a --> 'b 'b --> 'a) '(a (b (a) b) a))]

К частям выражения могут быть применены только унарные правила. В то же время, мультиарные правила могут применяться к последовательности аргументов.

Примеры:
@interaction[#:eval formica-eval
                (define g 
                  (/. (? Num x) --> (* x x) 
                      x y --> (* x y)))
                (g 4)
                (g '(4 5))
                (g 4 5)]


@defform[(define/. id rule-spec ...)]{Трансформируется в выражение @racket[(define id (/. rule-spec ...))].}

@section[#:tag-prefix "rewrite"]{Итеративные подстановки}

Правила итеративных подстановок бывают либо @emph{регулярными}, либо @emph{терминальными}. Они обозначаются стрелками @(defidform/inline -->) и @(defidform/inline -->.), соответственно.

Аппликация итеративной подстановки к заданному выраженю выполняется по следующему алгоритму:
@itemize{
 @item{Входные данные по очереди сопоставляются с образцами;}
  @item{в случае успешного сопоставления с образцом, производится соответствующее ему переписывание;}
  @item{если ни один из образцов не мог быть сопоставлен с данными, они возвращаются без изменений.}
  @item{Операция подстановки применяется к результату переписывания повторно, начиная с первого шага.}}
Система останавливается в двух случаях:
@itemize{
 @item{после применения терминального правила,}
  @item{если в результате подстановки данные не изменяются.}}


@defform/subs[#:id rewrite-repeated #:literals (--> -->. => ?) (rewrite-repeated rule-spec ...) 
([rule-spec (pat ... ar expr) 
(pat ... ar (=> id) expr) 
(pat ... ar (? guard) expr)]
[ar --> -->.])]
Трансформируется в функцию, итерационно применяющую правила @racket[rule-spec] к переданным
ей аргументам, и находящую их нормальную форму.

Стрелки  @racket[-->] и  @racket[-->.] соответствуют регулярным и терминальным переписывающим правилам соответственно.


@defform[(rewrite-all-repeated rule-spec ...)]
Трансформируется в функцию, итерационно применяющую правила
@racket[rule-spec] ко всем частям переданного ей аргумента.


@defform[(//. rule-spec ...)]
Сокращённая форма для @racket[rewrite-all-repeated].   

Примеры:
@interaction[#:eval formica-eval
                    ((//. 'a --> 'b 
                          'b --> 'c
                          'c --> 'd) '(a b c))]

@interaction[#:eval formica-eval
                    ((//. 'a -->. 'b 
                          'b --> 'c
                          'c --> 'a) '(a b c))]


@defform[(define//. id rule-spec ...)]{Трансформируется в выражение @racket[(define id (//. rule-spec ...))].}

@section[#:tag "patt"]{Образцы и шаблоны}

С помощью @elemtag["t:patt"]{@emph{образцов}} осуществляется синтаксический разбор 
аргументов подстановок с возможностью именования их частей.

@emph{Шаблоном} называется выражение, отражающее структуру разбираемого составного аргумента.
Ниже приводятся основные шаблоны, используемые при определении подстановок.
@racketgrammar[#:literals (? or and _ ___ +) patt 
                          datum 
                          id 
                          (id patt ...) 
                          (? func [id]) 
                          (or patt ...) 
                          (and patt ...)
                          (+ n x)
                          _ 
                          ___k 
                          ____]

@itemize{
 @item{@racket[_datum] --- элементарные данные: числа, квотированные символы и выражения, строки. 
        Соответствуют своим значениям.}
  @item{@racket[_id] --- символы-идентификаторы. 
        Соответствуют любому выражению и именуют его.}
  @item{@racket[(_id _patt ...)] --- составные данные: @elemref["t:pair"]{пары}, 
         @elemref["t:list"]{списки}, @elemref["t:formal"]{формальные функции}. 
         Символ @racket[_id] определяет тип данных и соответствует конструктору контейнерного типа,
         например, @racket[cons] --- для пары, @racket[list] --- для списков, или 
         @racket[f] --- для формальной функции @racket[f].
         Разбор и именование частей составных типов осуществляется
         с помощью шаблонов @racket[_patt ...].}
  @item{@racket[(? _func [_id])] --- охраняющий шаблон. Сопоставление с выражением
         происходит только в том случае, когда функция @racket[_func] возвращает для этого 
         выражения @racket[#t]. Необязательный символ-идентификатор используется, когда
         требуется поименовать сопоставленное выражение.}
  @item{@racket[(or _patt ...)] --- соответствует выражению, которое может быть сопоставлено с 
         любым из шаблонов @racket[_patt ...].}
  @item{@racket[(and _patt ...)] --- соответствует выражению, которое может быть сопоставлено со 
         всеми шаблонами @racket[_patt ...].}
  @item{@racket[(+ _n _x)] --- соответствует числу, при этом символ @racket[_x] связыватся с результатом вычитания @racket[_n] из этого числа.}
  @item{@racket[_] --- соответствует произвольному выражению.}
  @item{@racket[___k] --- соответствует последовательности из @racket[_k] и более произвольных выражений.
         Может быть введено, как @racket[_..k]. Пара шаблонов @racket[_id ___k] именует последовательность.}
  @item{@racket[____] --- соответствует последовательности (возможно, пустой) произвольных выражений.
         Может быть введено, как @racket[...] Пара шаблонов @racket[_id ____] именует последовательность.}}
  