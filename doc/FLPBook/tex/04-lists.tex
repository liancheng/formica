%!TEX root = main.tex
\Lesson{Составные структуры данных}\label{Less:lists}

\section[2]{Абстракция данных}%
Мы рассмотрели числовые и~логические данные, но их одних недостаточно для эффективного решения разнообразных встающих перед программистами задач. В~большинстве современных языков программирования существуют разнообразные \emph{составные данные}: массивы, структуры, объекты и~т.\,п. Их использование делает возможной \index{абстракция!данных}\emph{абстракцию данных}. Абстракция данных~--- это методология, которая позволяет отделить способ использования составного объекта данных от~деталей того, как он составлен из~элементарных данных.


\section[2]{Точечные пары}\label{pair}%
\index{пара (точечная)}Во многих функциональных языках программирования в~качестве базового инструмента для конструирования составных данных используется \emph{пара}. В~\Scheme пары называются \emph{точечными парами} или \emph{cons\=/ячейками}. Нам они потребуются для самых разнообразных целей, как универсальный контейнер, позволяющий группировать данные.

Для работы с парами используются конструктор пары и функции\=/селекторы.

\begin{example}{%
Конструктором пары является функция \sbi{cons}. Интерпретатор выводит результат в~виде точечной пары: \s{(expr1 . expr2)}.}
\REPL
  {(cons 1 2)}
  {(1 . 2)}
\end{example}

\begin{example}{%
Для доступа к~элементам пары используются функции\=/селекторы \sbi{car}, которая возвращает первый элемент пары, и \sbi{cdr}, возвращающая второй элемент пары}
\REPL
  {(car (cons 1 2))}
  {1}

\REPL
  {(cdr (cons 1 2))}
  {2}
\end{example}

\begin{example}{%
Пары могут быть вложенными.}
\REPL
  {(cons (cons 1 2) 3)}
  {((1 . 2) . 3)}
\end{example}

\begin{example}{%
Вложенные справа пары образуют списочную структуру.}
\REPL
  {(cons 1 (cons 2 3))}
  {(1 2 . 3)}
\end{example}

\begin{example}{%
Предикат \sbi{pair?} определяет, является выражение парой или атомом.}
\REPL
  {(pair? (cons 1 2))}
  {\#t}
\REPL
  {(pair? 1)}
  {\#f}
\end{example}

Тип пары объектов, имеющих типы \Type{A} и~\Type{B} обозначим, как \mbox{\Type{(A . B)}}. Скажем, пара двух чисел будет иметь тип \Type{(Num . Num)}.

\section[2]{Списки}\index{список}%
Когда мы обсуждали синтаксис выражений \Scheme, мы говорили, что выражение может быть либо атомом, либо списком. Теперь мы готовы дать строгое определение списку.

Списком является или \emph{пустой список}\index{пустой список} или \emph{пара}, второй элемент которой является списком. Для пустого списка используется символ~\sbi{null}.

Это определение может пояснить формальное описание типа \Type{[A]}, обозначающего список элементов, имеющих тип \Type{А}:

\index{тип!алгебраический!список []}
\begin{type}\item\label{list-type}
[A] ::= \s{null} | (A . [A])
\end{type}

Чтобы списочная структура стала списком, необходимо, чтобы самая последняя из~вложенных пар имела вторым элементом пустой список. Для конструирования списков используется функция \si{list}~--- её аргументы и~являются содержимым списка.

Таким образом, например, списками будут являться:

\smallskip
\noindent
\begin{tabular}{ll>{\comment}p{2.5cm}}
\begin{ExampleCode}
 null
\end{ExampleCode}& 
\begin{ExampleCode}
 (list)
\end{ExampleCode}& пустой список\\
\begin{ExampleCode}
 (cons 1 null)
\end{ExampleCode}&
\begin{ExampleCode}
 (list 1)
\end{ExampleCode}& список из одного элемента\\
\begin{ExampleCode}
 (cons 1 
       (cons 2 null))
\end{ExampleCode}&
\begin{ExampleCode}
 (list 1 2)
\end{ExampleCode}& список из двух элементов\\
\begin{ExampleCode}
 (cons (cons 1 2) 
       (cons (cons 2 3) 
             null))
\end{ExampleCode} &
\begin{ExampleCode}
 (list (cons 1 2) 
       (cons 2 3))
\end{ExampleCode} & список из двух элементов-пар
\end{tabular}


\begin{example}{%
Если мы попытаемся ввести список без~конструктора, то получим сообщение об~ошибке, поскольку интерпретатор будет пытаться вычислить это выражение, как функцию 1 с~аргументами 2 и~3.}
\REPLin
  {(1 2 3)}

{\errorstyle procedure application: expected procedure, given: 1; arguments were: 2 3}
\end{example}

Списки можно создавать и~без использования конструкторов, через кавычку \s{'}\index{Racket!базовые формы!quote@\s{'} (\s{quote})}:

\begin{example}{Сокращённый ввод списков.

Последний пример показывает, как можно ввести матрицу. При~этом кавычка ставится только один раз, снаружи.}
\REPL
  {'(1 2 3)}
  {(1 2 3)}

\REPL
  {'(1)}
  {(1)}

\REPL
  {'((1 2) (3 4))}
  {((1 2) (3 4))}
\end{example}

Фундаментальное отличие ввода списков с~использованием конструктора и~с помощью кавычки заключается в~том, вычисляются ли элементы списка. Напомним, что интерпретатор \Scheme сначала вычисляет аргументы функции, а~потом саму функцию. Конструктор \s{list}~--- это функция, поэтому она создаёт список, предварительно вычислив все его элементы. Кавычка же имеет особый смысл: она оставляет элементы выражения невычисленными. 

Таким образом, если мы хотим ввести список констант, можем смело использовать кавычку. Если же элементы списка ещё нужно вычислить, используем явное обращение к~конструктору \s{list}.

\begin{example}{Разница между использованием \s{list} и~\s{'} при~создании списков.}
\REPL
  {(list (+ 1 2) (* 2 3))}
  {(3 6)}

\REPL
  {'((+ 1 2) (* 2 3))}
  {((+ 1 2) (* 2 3))}
\end{example}

\begin{example}{Так как кавычка оставляет выражение невычисленным, с~её помощью мы можем вводить списки символов, не~определяя их значений.}
\REPLin
  {(list a b c)}

{\errorstyle reference to an identifier before its definition: a}

\REPL
  {'(a b c)}
  {(a b c)}
\end{example}

\begin{example}{Предикат \sbi{list?} определяет, является ли объект списком.}
\REPL
  {(list? '(1 2))}
  {#t}

\REPL
  {(list? (cons 1 null))}
  {#t}

\REPL
  {(list? (cons 1 2))}
  {#f}
\end{example}

В языке \Scheme списки используются в~качестве динамических массивов и~для представления деревьев, их можно так же использовать для работы с~векторами и~матрицами\footnote{В \Scheme существует тип данных \s{vector}, соответствующий индексированному массиву, но в~рамках этого курса мы его рассматривать не~будем.}. Мы будем использовать их, как универсальный контейнер для разнообразных данных.

\section[2]{Пустой список}\index{пустой список}%
Объект \sbi{null}, обозначающий пустой список, стоит особняком в~ряду используемых типов данных языка \Scheme. Мы говорили, что этот язык работает с атомами, парами или списками, при этом, все списки составляются из пар. Таким образом, можно утверждать, что всякий список является парой. Исключением здесь является символ \s{null}.

\begin{example}{%
Пустой список является списком, но не~является парой.} 
\REPL
  {(list? null)}
  {#t} 

\REPL
  {(pair? null)}
  {#f}
\end{example}

При разборе списков нам необходимо отличать произвольные атомы от~пустого списка. Для этого служит предикат \sbi{null?} или его синоним \sbi{empty?}.

\begin{example}{%
Предикат \s{null?} возвращает \s{\#t}  только для пустого списка.
Предикат \s{empty?} является синонимом \s{null?}. Его используют, когда речь идёт именно о~списке без~элементов.}

\REPL
  {(null? null)}
  {#t}
\REPL
  {(null? 1)}
  {#f}
\REPL
  {(null? (cons 1 2))}
  {#f}
\REPL
  {(empty? null)}
  {#t}
\end{example}

\begin{example}{Создать пустой список можно тремя способами.

Чаще всего, мы будем использовать последний.}
\REPL
  {null}
  {()}

\REPL
  {(list)}
  {()}

\REPL
  {'()}
  {()}
\end{example}

\section[2]{S-выражения}\label{Sec:S-expr}%
Мы увидели, что списки составляются из~точечных пар, которые являются наиболее примитивными составными структурами данных в~языке \Scheme. Теперь мы можем дать исчерпывающее определение структуре, которой являются все выражения \Scheme~--- \emph{S-выражению.}

\index{S-выражение}S-выражение (\emph{символьное выражение}) может быть либо атомом, либо парой, элементами которой являются S-выражения, либо пустым списком. 

Приведём соответствующее этому определению описание типа для S-выражения:
\begin{type}
S-Expr ::= Atom | (S-Expr . S-Expr) | null
\end{type}

Таким образом, научившись работать со~списками, мы научимся работать с~произвольными выражениями нашего языка.

\section[4]{Функции с~неопределённым числом аргументов}%
Рассматривая синтаксис языка \Scheme, мы упоминали, что все составные выражения имеют голову, играющую роль имени функции и~хвост~--- список аргументов функции. Так как все выражения \Scheme составляются из~точечных пар, голова выражения (имя функции) --- это \s{car} выражения, а~список аргументов~--- его \s{cdr}.

На этом основан синтаксис определения функций с~неопределённым числом аргументов, таких, как функции \s{+} или \s{-}.

\begin{example}{%
В этом примере мы определили простейшую функцию, возвращающую список переданных ей аргументов. Можно заметить, что по~своему поведению данная функция не~отличима от~конструктора списка \s{list}.}

\REPLin
  {(define (f . x) x)}
\REPL
  {(f 1 2 3 4)}
  {(1 2 3 4)}
\REPL
  {(f 1)}
  {(1)}
\REPL
  {(f)}
  {()}
\end{example}
\vspace{-\bigskipamount}
\begin{example}{%
Так определяется функция, принимающая один и более аргументов. При этом символ \lex{y} связывается со списком аргументов. Если передан только один аргумент -- этот список будет пустым.}

\begin{ExampleCode}[emph={x,y}]
> (define (f x . y)
    (list x y))
\end{ExampleCode}
\REPL
  {(f 1 2 3)}
  {(1 (2 3))}
\REPL
  {(f 1)}
  {(1 ())}
\end{example}

Анонимная функция с~неопределённым количеством аргументов определяется таким образом:
\begin{SchemeCode}[emph={x}]
        (lambda x body) %\rmfamily или подстановкой% (/. x ___ --> body)
\end{SchemeCode}
\noindent при~этом \lex{x}~--- это список аргументов, переданных функции.

\begin{example}{%
Так с~помощью \lmфункции можно определить функцию \s{list}.}
\REPLin
  {(define list (lambda x x))}
\REPL
  {(list 1 2 3)}
  {(1 2 3 4)}
\REPL
  {(list 1)}
  {(1)}
\REPL
  {(list)}
  {()}
\end{example}

\label{variadic-rewrite}Подстановка \s{(/. x y z ___ --> body)} и форма \s{(lambda (x y . z) body)} определяют функцию, принимающую два и более аргументов.

\section[4]{Базовые функции для работы со~списками}%
Списки играют очень важную роль и~в синтаксисе языка \Scheme и~в~конструировании различных типов данных, с~которыми он~работает. Поэтому язык предоставляет богатый инструментарий для работы со~списками. Приведём лишь самые общие и~часто используемые функции из~большого множества функций, оперирующих со~списками.


\begin{example}{Функция \fun{make-list}{n x} создаёт списки длиной \lex{n} с~заданными  элементами \lex{x}}
\REPL
  {(make-list 5 3)}
  {(3 3 3 3 3)}
\end{example}

\begin{example}{Функция \fun{length}{lst}, возвращает длину списка \lex{lst}}
\REPL
  {(length '(a b c d))}
  {4}
\end{example}

\begin{example}{Некоторые функции доступа к~элементам списка \fnindex{first}\fnindex{rest}\fnindex{second}\fnindex{last}}
\REPL
  {(first '(a b c d))}
  {a}

\REPL
  {(rest '(a b c d))}
  {(b c d)}

\REPL
  {(second '(a b c d))}
  {b}

\REPL
  {(last '(a b c d))}
  {d}
\end{example}

\begin{example}{Извлечение частей списка по индексам осуществляется функциями \fun{list-ref}{lst n}, \fun{take}{lst n} и \fun{drop}{lst n}.

Первый элемент имеет нулевой порядковый номер.}
\REPL
  {list-ref '(a b c d) 3)}
  {d}

\REPL
  {(take '(a b c d) 2)}
  {(a b)}

\REPL
  {(drop '(a b c d) 2)}
  {(c d)}
\end{example}

\begin{example}{Структурные операции.\fnindex{append}\fnindex{cons}\fnindex{reverse}}
\REPL
  {(append '(a b c) '(d e))}
  {(a b c d e)}

\REPL
  {(cons 0 '(a b c d))}
  {(0 a b c d)}

\REPL
  {(reverse '(a b c d))}
  {(d c b a)}
\end{example}

\section{Структурная рекурсия}\label{struct-recursion}%
Обработка списка подразумевает перебор его элементов. В императивных языках, в которых в качестве списка применяются массивы, для этого используют цикл по индексу. Время доступа к элементу массива по индексу от индекса не зависит, так что на обработку массива из $N$ элементов требуется $O(N)$ шагов. 

Однако, для односвязных списочных структур, которыми являются списки, чтобы получить $i$-тый элемент списка необходимо совершить $i$ переходов от одного элемента к другому. Так что индексная обработка списка длиной $N$ потребует $O(N^2)$ шагов.

Если требуется обработать все элементы списка по порядку, лишней работы можно избежать. Для этого cписки следует обрабатывать так же, как обрабатывается ряд натуральных чисел в процедурах \s{sum} и \s{accumulate}. 

Натуральные числа образуют \emph{индуктивное (рекурсивное) множество}\index{индуктивное множество}, определяемое базовым элементом -- нулём, и функцией следования $S$, которая любому числу ставит в соответствие следующее за ним число: $S(N)=N+1$. 

Таким образом, определение функции \s{sumsq}, данное на стр. \pageref{sumsq}, можно записать так:

\begin{SchemeCode}
  sumsq $0 = 0$
  sumsq $(N + 1) = (N+1)^2$ $+$ sumsq $N$
\end{SchemeCode}

Списки тоже образуют индуктивное множество. Их базовый элемент --- это пустой список \s{null}, а функция следования --- конструктор пары \s{cons} (см. определение типа для списка на стр. \pageref{list-type}).

Это означает, что по аналогии с функцией \s{sumsqr} мы можем определить функцию \s{list-sumsqr}, вычисляющую сумму квадратов элементов списка:

\begin{SchemeCode}
  list-sumsq null $=$ $0$
  list-sumsq $($cons $h$ $t)$ $=$ $h^2$ $+$ list-sumsq $t$
\end{SchemeCode}

Для списка \s{lst = (cons $h$ $t$)} его части равны, соответственно, \s{$h$ = (car lst)}, \s{$t$ = (cdr lst)}. Таким образом, получаем рекурсивную программу:

\begin{SchemeCode}
  list-sumsq null $=$ $0$
  list-sumsq $lst$ $=$ $($car $lst)^2$ $+$ list-sumsq $($cdr $lst)$
\end{SchemeCode}
которую можно записать на языке \Scheme:
\begin{SchemeCode}[emph={lst}]
(define (list-sumsqr lst)
  (if (null? lst)
      0
      (+ (sqr (car lst)) (list-sumsq (cdr lst)))))
\end{SchemeCode}

\index{рекурсия!структурная}Подобная рекурсивная обработка индуктивных множеств для $N$ элементов потребует $O(N)$ шагов и гарантированно завершится, поскольку индуктивное множество подразумевает наличие базового элемента. Такая рекурсия называется \emph{структурной}.

\index{подстановка}%
Используя подстановки, можно записывать программы для структурно\=/рекурсивных функций, непосредственно следуя их определениям. Например:

\begin{SchemeCode}[emph={h,t}]
(define list-sumsqr
  (/. '() --> 0
      (cons h t) --> (+ (sqr h) (list-sumsq t))))
\end{SchemeCode}

Это определение использует то, что функция-конструктор \s{cons} не выполняет никаких действий над своими аргументами. Она является только контейнером. Получить доступ к элементам контейнера можно либо с помощью функций-селекторов -- \s{car} и \s{cdr}, либо через шаблон \s{(cons $h$ $t$)}, непосредственно именующий части контейнера символами $h$ и $t$.\footnote{О~шаблонах мы будем говорить подробнее на~Занятии~\ref{Less:rewriting}.}

Типы данных, определяемые подобными конструкторами, называются \emph{абстрактными типами}\index{тип!абстрактный}. Они широко используются в функциональных языках программирования. На Занятии \ref{} мы узнаем, как можно строить новые абстрактные типы данных.

\section{Рекурсивные типы данных}
Итак, натуральные числа и списки образуют индуктивные множества, которые можно описать с помощью индуктивных определений: базы индукции и функций следования (их может быть несколько). Это компактный способ описания перечислимых, возможно, бесконечных множеств, позволяющий строить структурно-рекурсивные функции для обработки любых элементов этих множеств.

В системе типов \Scheme множества, к которым принадлежат величины, определяют тип величны. Таким образом, необходимо иметь возможность определения типа, соответствующего индуктивному множеству. Для этого естественно использовать рекурсию.

\begin{example}{Рекурсивное определение для типа "список". Предикат \s{(cons: A B)} является определителем типа: пара элементов, имеющих тип \s{A} и \s{B}.}
\begin{SchemeCode}[emph={h,t}]
(define-type List
  '()
  (cons: Any List))
\end{SchemeCode}
\end{example}

\begin{Assignment}
Напишите свои определения для функций \s{make-list}, \s{take} и~\s{append}:

\begin{Specification}
; make-list :: A Int \arrow [A]
(test 
  (make-list 1 3)      ==> '(1 1 1)
  (make-list '(1 2) 3) ==> '((1 2) (1 2) (1 2))
  (make-list 1 0)      ==> '()
  (make-list 1 -1)     ==> '() )
\end{Specification}

\vspace{-\medskipamount}
\begin{Specification}
; take :: [A] Int \arrow [A]
(test 
  (take '(1 2 3) 2)    ==>  '(1 2)
  (take '(1 2 3) 0)    ==>  '()
  (take '(1 2 3) 4)    ==>  '(1 2 3)
  (take '(1 2 3) -1)   ==>  '() )
\end{Specification}

\vspace{-\medskipamount}
\begin{Specification}
; append :: [A] [A] \arrow [A]
(test 
  (append '(1 2 3) '(a b c)) ==>  '(1 2 3 a b c)
  (append '() '(1 2 3))      ==>  '(1 2 3)
  (append '() '())           ==>  '() )
\end{Specification}
\end{Assignment}

\begin{Assignment}
С помощью функции \s{accumulate} (см.~\Asref[б]{accumulate}), напишите функцию \fun{table}{f a b}, возвращающую список значений произвольной функции \lex{f} в~целых числах от~\lex{a} до~\lex{b}.

\begin{Specification}
; table :: (Num \arrow A) Int Int \arrow [A]
(test 
  (table sqr 1 3)    ==> '(1 4 9)
  (table (+ 1) 0 3)  ==> '(1 2 3 4)
  (table list -1 1)  ==> '((-1) (0) (1))
  (table sqr 3 1)    ==> '() )
\end{Specification}

Выразите через неё функцию \fun{range}{a b} возвращающую список целых чисел от \lex{a} до \lex{b}.
\begin{Specification}
; range :: Int Int \arrow [Int]
(test 
  (range 1 4)   ==> '(1 2 3 4)
  (range -1 1)  ==> '(-1 0 1)
  (range 3 3)   ==> '(3)
  (range 3 1)   ==> '() )
\end{Specification}
% \vspace{-\bigskipamount}
\end{Assignment}

\begin{Assignment}
а) Напишите определение для функции \fun{map}{f lst}, возвращающей список из~результатов применения функции \lex{f} к~каждому из~элементов списка \lex{lst}. Эта очень важная функция называется \index{отображение списка}\emph{отображением списка} или \emph{множества}.
\begin{Specification}
; map :: (A \arrow B) [A] \arrow [B]
(test 
  (map sqr '(1 2 3))  ==> '(1 4 9)
  (map list '(a b c)) ==> '((a) (b) (c)) )
\end{Specification}

б) Напишите определение функции \fun{zip}{f lst1 lst2}, которая бы возвращала список результатов попарного применения бинарной функции \lex{f} к~элементам списков \lex{lst1} и~\lex{lst2}.
\begin{Specification}
; zip :: (A B \arrow C) [A] [B] \arrow [C]
(test 
  (zip + '(1 2 3) '(3 4 5)) ==> '(4 6 8)   ;$(1+3\ 2+4\ 3+5)$
  (zip cons '(a b) '(1 2))  ==> '((a . 1) (b . 2)))
\end{Specification}

Продумайте, как должна реагировать ваша функция на~списки неравной длины.
\end{Assignment}

\section{Списки за~пределами~\Scheme}%
\index{списочные структуры}Списочные структуры, списки или кортежи, как инструмент для работы с~динамическими и~нетипизированными массивами широко используются в~программировании. Очень многие современные языки имеют базовые средства для создания и~обработки списков или кортежей. Практически во~всех функциональных языках списки устроены так же, как в~\Scheme, в~виде однонаправленной списочной структуры.

В нефункциональных языках, таких, как \Lang{С++} или \Lang{Pascal} (\Lang{Delphi}) такие структуры реализуются на~указателях и~записях. Существуют стандартные библиотеки с~инструментарием для работы со~списками. Например, Standard Template Library для \Lang{C++} или LINQ для~\Lang{C\#}.

\begin{Queeze}

 \item Что такое «абстракция данных»?

 \item Какие операции существуют для списков? Зависит ли смысл этих операций от~реализации списков?

 \item Что такое точечная пара? Какова связь между списками и~парами в~языке \Scheme?

 \item Как в~языке \Scheme определить функцию от~произвольного числа аргументов?

 \item Что такое индуктивное множество?

 \item Что такое структурная рекурсия, и какие преимущества даёт её использование?
 
 \item Что такое абстрактный тип данных?


\end{Queeze}
\endinput