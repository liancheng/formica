%!TEX root = main.tex
\Lesson{Отложенные вычисления}\label{Less:delayed-computation}

\section[4]{Аппликативный и~нормальный порядок вычисления}%
\label{normal-order}Мы уже рассказывали, каким образом интерпретатор \Scheme вычисляет выражения: сначала вычисляются оператор и~операнды, а~затем получившаяся процедура применяется к~получившимся аргументам (см. Занятие \ref{Less:functions}, стр.\,\pageref{applicative-order}).

Существует и~другая модель, в~которой вычисление аргументов не~производится до~тех пор, пока не~понадобится их значение. Вместо этого в~функцию подставляются выражения-операнды, до~тех пор пока не~получится выражение, в~котором присутствуют только элементарные операторы, и~лишь затем производится вычисление всего выражения. Этот второй метод известен под~названием \index{порядок вычисления!\emph{нормальный}}\emph{нормальный порядок вычислений}.

Вычисления, основывающиеся на~аппликативном порядке называются \index{вычисления!интенсивные}\emph{интенсивными}, а~на нормальном~--- \index{вычисления!ленивые}\emph{ленивыми}. Существуют \index{языки программирования!\emph{ленивые}}\emph{ленивые языки программирования} в~которых используется только нормальный порядок вычислений. Ярким примером таких языков является язык \Lang{Haskell}.

\section[2]{Специальные формы}\index{специальная форма}%
В языке \Scheme преимущественно используется аппликативный порядок. Но никакой язык программирования не~сможет обойтись только им. 

Рассмотрим, для примера, как выполняется конструкция ветвления \s{(if test? P${}_1$ P${}_2$)}. В~зависимости от~результата процедуры \s{test?}, может быть выполнена либо процедура \s{P${}_1$} либо \s{P${}_2$}. Нам незачем сначала вычислять и~ту и~другую ветвь с~тем, чтобы выбрать результат одной из~них. Поэтому вычисление формы \s{if} не~должно подчиняться аппликативному порядку. 

Мы называем \s{if} или~\s{cond} не~функциями, а~\emph{специальными формами}~--- то есть конструкциями языка с неаппликативным порядком вычисления. Специальные формы сначала оперируют переданными им в~качестве аргументов выражениями, не~вычисляя их, и~только затем проводят вычисления, если это необходимо.

В~виде специальных форм определены и~логические операции \s{or} и~\s{and}. К~специальным формам относятся также \s{define} и~\s{lambda}~--- тела функций, которые описываются с~их помощью, не~должны вычисляться прежде, чем эти функции будут вызваны.


\section[2]{Макросы}\index{макрос}\label{macro}%
Возможность вводить в~язык \Scheme специальные формы обеспечивается механизмом \emph{макросов}. Макрос описывает \emph{синтаксическое преобразование выражения без~его вычисления}. \Scheme имеет чрезвычайно богатые средства для макропрограммирования.  

Здесь мы не~будем подробно останавливаться на~технике написания макросов, а~только укажем, как можно создать простейшую специальную форму с~их помощью. В~самом простом случае, описание макроса с именем \lex{name} имеет следующий вид:

\bsfindex{define-syntax-rule}
\begin{Specification}[emph={name,pat}]
(define-syntax-rule (name pat)
    body)
\end{Specification}

\noindent Здесь \lex{pat}~--- образец трансформируемой формы. В~элементарном случае, он может быть оформлен, подобно тому, как это делается в~определениях с~помощью формы \s{define}. Выражение \s{body} представляет собой выходное выражение, в~которое трансформируется форма.

Вот, например, определение простейшей формы \si{or}, выполненное с~помощью макроса:

\sfindex{or}
\begin{Definition}[emph={x,y}]
(define-syntax-rule (or x y)
  (if x x y))
\end{Definition}

Это определение предписывает выражение \s{(or x y)} переписать, как \s{(if x x y)}. Именно \emph{переписать} и~только потом вычислить. Основное отличие макроса от~обыкновенной функции и~состоит в~том, что его трансформация происходит до~компиляции. При~этом не~используются никакие связывания, возникающие во~время исполнения программы. Такой подход, характерный для языка \Lang{Scheme}, получил название «гигиеничный макрос».

\section{Когда использовать макросы?}%
Макропрограммирование позволяет существенно расширять синтаксис языка, добавляет ему выразительности и~делает его более предметно ориентированным. Однако, если какие-то из~этих задач можно решить с~помощью функций, стоит использовать функции.

\index{объект первого класса}Важным отличием синтаксической формы от~функции является то, что формы \emph{не являются объектами первого класса} языка \Scheme. Их невозможно комбинировать с  другими функциями. Для этого специальные формы приходится «прятать» внутрь функций.

Кроме того, как мы уже говорили, макросы позволяют обходить аппликативный порядок вычислений, это полезно, но только если это происходит осознанно, и~оправдано постановкой задачи. В~противном случае, нарушается стройность и единообразие функционального подхода, обеспечивающие его гибкость и расширяемость. К тому же, злоупотребление макросами может существенно затруднить анализ и отладку программы.

Таким образом, можно сказать, что макросы нужно применять только тогда, когда без~них обойтись невозможно.

\section{Отложенные вычисления}%
\label{delay}Несмотря на~то, что \Scheme не~является ленивым языком, мы можем расширить его так, что нам станут доступны некоторые приёмы ленивых вычислений.

\index{вычисления!отложенные}\emph{Отложенные вычисления} базируются на~том, что мы можем задержать вычисление того или иного выражения до~тех пор, пока это нам не~потребуется. Основой для реализации отложенных вычислений будут форма \sfi{(delay expr)}, оставляющая выражение \s{expr} невычисленным, до~тех пор, пока вычисление не~потребуется, и~функция \si{force}, которая вынуждает произвести задержанное вычисление.
\label{lazy}Вот, пример простой реализации этой пары:

\begin{Definition}
(define-formal (delayed 1))

(define-syntax-rule (delay expr)
  (delayed (lambda () expr)))

(define force
  (/. (delayed expr) --> (expr)))
\end{Definition}
\newpage

С помощью формальной функции \s{delayed} мы определили абстрактный полиморфный тип для задержанных вычислений. Собственно, вычисления задерживаются с помощью \lmфункции. Здесь мы пользуемся тем, что \lmфункция не~вычисляет своё тело до~тех пор, пока она не~будет вызвана с~каким-либо аргументом. А~функция \s{(lambda () expr)} не~будет требовать никаких аргументов. Такую структуру называют термином \emph{санк}\index{санк} (англ. \emph{thunk}). Функция \s{force} \emph{вычисляет} эту функцию, вызывая её без аргументов. 

Покажем, зачем могут понадобиться ленивые вычисления, на~примере обобщения рекурсивного обхода списка в~виде свёртки. Недостатком свёртки является то обстоятельство, что независимо от~необходимости, список проходится полностью. Тогда, как, например, для функции \fun{any}{test? lst}, проверяющей, есть ли в~списке \lex{lst} элементы, удовлетворяющие условию \lex{test?}, следовало бы остановить поиск, как только найдётся первый подходящий элемент. Вот каким образом мы можем определить эту функцию через свёртку:

\begin{Definition}[emph={el,res,test?,lst}]
(define/c (any test?)
  (foldr (lambda (el res) (or (test? el) res)) #f))
\end{Definition}

Свёртка~--- достаточно мощная и~удобная абстракция, и~отказываться от~неё не~хотелось бы. Вместо этого, модифицируем её, определив ленивую свёртку\index{свёртка!ленивая}\fnindex{foldr~}:

\begin{Definition}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
 (define/c (foldr~ f $x_0$)
   (/. '() --> $x_0$
       (cons h t) --> (f h (delay (foldr~ f $x_0$ t))))))
\end{Definition}
Определяя функцию \s{foldr~}, мы с~помощью формы \s{delay} задерживаем рекурсию, откладывая на~потом вычисление второго аргумента функции \lex{f}.

Посмотрим, как воспользоваться ленивой свёрткой, для определения функции \s{any?}:

\begin{Definition}[emph={test?,lst,el,res}]
(define/c (any~ test?)
  (foldr~ (lambda (el res) (or (test? el) (force res))) #f))
\end{Definition}
Теперь вычисление второго аргумента сворачивающей \lmфункции происходит только тогда, когда тест для очередного элемента не~выполняется. Если же тест пройден успешно, форма \s{or} возвращает \s{#t} и~рекурсия заканчивается.
\newpage

Так как мы работаем в рамках чистого функционального программирования, поведение функций \s{any} и \s{any~} будет неотличимым: на одинаковых данных они всегда возвращают одинаковый результат, так что тесты не выявят разницы в вычислительном процессе. Чтобы убедиться в том, что ленивый вариант действительно ленив, нужно добавить какой-либо побочный эффект, например вывод промежуточных результатов. Для этого напишем простой оператор, преобразующий любую функцию в <<говорящую>>:
\begin{Definition}[emph={f,x}]
(:: verbose (Fun -> Fun)
 (define (verbose f)
   (lambda x 
     (displayln (apply (hold f) x))
     (apply f x))))
\end{Definition}
Теперь мы можем убедиться в том, что функция \s{any~}, в отличие от \s{any}, завершает работу вовремя:
\REPLin{(any~ (verbose odd?) '(0 3 2 4))}
\REPLout{(odd? 0)}\vspace{-\smallskipamount}
\REPLout{(odd? 3)}\vspace{-\smallskipamount}
\REPLout{#t}
    
\REPLin{(any (verbose odd?) '(0 3 2 4))}
\REPLout{(odd? 0)}\vspace{-\smallskipamount}
\REPLout{(odd? 3)}\vspace{-\smallskipamount}
\REPLout{(odd? 2)}\vspace{-\smallskipamount}
\REPLout{(odd? 4)}\vspace{-\smallskipamount}
\REPLout{#t}

\begin{Assignment}
а) Реализуйте функцию \fun{take-while}{test? lst}, которая возвращает часть списка \s{lst} до~первого элемента, не~удовлетворяющего условию \s{test?}.

\begin{Specification}
(test
  (take-while (curryr < 3) '(1 2 3 4 5))  ==> '(1 2)
  (take-while (curryr < 3) '(5 6 7 8))    ==> '())
\end{Specification}
Убедитесь в том, что ваша функция делает только необходимые вычисления.

б) Для того, чтобы воспользоваться приведённым выше вариантом \s{foldr~}, пришлось в определении функции \s{any~}  переписывать сворачивающую \lmфункцию. К тому же, мы были вынуждены использовать особые свойства формы \s{or}. Этого можно избежать, если ленивую свёртку организовать следующим образом:
\begin{SchemeCode}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
 (define/c (foldr~ f $x_0$)
   (/. '() --> $x_0$
       (cons h t) --> (force (f h (delay (foldr~ f $x_0$ t)))))))
\end{SchemeCode}
Тогда можно будет использовать определение функции \s{any~}, не отличающееся от неленивого:
\begin{SchemeCode}[emph={el,res,test?,lst}]
(define/c (any test?)  (foldr  ($\circ$ or test?) #f))
(define/c (any~ test?) (foldr~ ($\circ$ or test?) #f))
\end{SchemeCode}
Это обеспечивает большую модульность, поскольку вся информация о характере вычислений сосредотачивается в функции свёртки.

Реализуйте этот вариант ленивой свёртки (для этого надо будет немного изменить определение для \s{force}). Реализуйте с её помощью функцию \s{take-while}.
\end{Assignment}


\section{Отложенные списки и~потоки}%
\index{отложенные списки}%
\index{поток}%
Как видим, ленивые вычисления дают нам определённую свободу в~управлении потоком вычисления. Но это ещё не~все, на~что они способны. С~помощью \s{delay} и~\s{force} мы реализуем так называемые \emph{отложенные} или \emph{ленивые списки}, которые позволят нам эффективно описывать \emph{потоки}~--- последовательности данных, потенциально бесконечные или цикличные.

Отложенный список будет устроен так же, как и~обыкновенная списочная структура~--- в~виде последовательности вложенных пар. Разница между ними состоит в~том, что вычисляется аппликативно только голова пары, в~то время, как вычисление её хвоста является отложенным и~будет выполняться только по~необходимости.

Таким образом, нам потребуется конструктор пары, задерживающий вычисление второго её элемента. Мы должны оформить конструктор отложенной пары в~виде специальной формы, поскольку нам необходимо, чтобы он не~вычислял свой второй аргумент. То есть он не~должен следовать аппликативному порядку вычислений.

\newpage
\label{lazy-cons}Вот один из возможных вариантов реализации конструктора отложенной пары, назовём его \s{cons~}\sfindex{cons~}:

\begin{Definition}[emph={h,t}]
(define-syntax-rule (cons~ h t)
   (cons h (delay t)))
\end{Definition}

Определим теперь селекторы \s{car~} и~\s{cdr~} для работы с~отложенными парами:

\begin{Definition}
(:: car~ (pair? -> Any)
 (define (car~ s) (car s)))

(:: cdr~ (pair? -> Any)
 (define (cdr~ s) (force (cdr s))))
\end{Definition}

Функция \s{car~} возвращает первый элемент пары, а~функция \s{cdr~} \emph{вычисляет} второй элемент с~помощью функции \s{force}. Таким образом, вычисление второго элемента будет происходить только при~вызове \s{cdr~}.

\begin{example}{Попробуем составить какую-нибудь пару. Как и~ожидалось, вторым её элементом является задержанная функция, а~\s{cdr~} от~нашей пары вынуждает провести отложенные вычисления.}
\REPLin
  {(define x (cons~ 1 2))}
\REPL
  {x}
  {(1 delayed \#<procedure>)}
\REPL
  {(list (car~ x) (cdr~ x))}
  {(1 2)}
\end{example}

\begin{example}{Так мы можем определить отложенную списочную структуру \s{(0 . (1 . 2))}.}
\REPLin
  {(define y (cons~ 0 x))}
\REPL
  {y}
  {(0 delayed \#<procedure>)}
\REPL
  {(cdr~ y)}
  {(1 delayed \#<procedure>)}
\end{example}

А теперь давайте воспользуемся нашими достижениями для следующего сомнительного определения:

\begin{Definition}
(define ones (cons~ 1 ones))
\end{Definition}

Если бы мы следовали подстановочной модели с~аппликативным порядком вычислений, то мы бы получили бесконечную рекурсию или сообщение об~ошибке. Однако, в~случае отложенных пар мы описали нечто вполне осмысленное. Посмотрим, что мы получим, вычисляя \s{ones} и~его части:

\REPL
  {ones}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ ones)}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ ones))}
  {(1 delayed \#<procedure>)}

Получается, что сколько бы раз мы ни~вычисляли \s{cdr~} от~пары \s{ones}, мы всегда будем получать один и~тот же результат и~никогда не~достигнем какого-либо конца. Эффективно, \s{ones} ведёт себя, как \emph{бесконечная} последовательность единиц: \s{(1 . (1 . (1 . ...)))}! Такие структуры будем называть \emph{потоками}.

Мы будем считать концом потока (если он не~бесконечен), объект \s{null}, также, как для списков. Дадим определение полиморфного алгебраического типа для потока \index{тип!алгебраический!поток \{\}} :

\begin{Definition}
(define-type (Stream A)
  '()
  (cons: A delayed?))
\end{Definition}
\REPL{(is ones (Stream 1))}{#t}

Приведём ещё один пример бесконечного потока:

\begin{Definition}[emph={n}]
(:: enum (Stream Num)
 (define (enum n)
   (cons~ n (enum (+ n 1)))))
\end{Definition}

\REPL
  {(enum 2)}
  {(2 delayed \#<procedure>)}

\REPL
  {(cdr~ (enum 2))}
  {(3 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ (enum 2)))}
  {(4 delayed \#<procedure>)}

Поток \s{(enum $n$)} описывает бесконечный ряд целых чисел, начинающихся с~$n$.

Теперь мы в~состоянии породить поток натуральных чисел:
\begin{Definition}
(:: enum (Stream Nat)
  (define naturals (enum 1)))
\end{Definition}
\newpage

\section[2]{Обработка потоков}%
По существу, обыкновенные списки и~отложенные не~отличаются друг от~друга. Устроены они одинаково~--- это последовательность вложенных пар; доступ к~элементам списка у~них одинаков, он осуществляется с~помощью селекторов головы и~хвоста списка. Это значит, что и~процедуры обработки этих списков, такие, например, как извлечение элемента по~номеру, отображение, фильтрация и~т.\,п. будут реализованы одинаково, как для обыкновенных списков, так и~для задержанных.

Для начала, создадим способ увидеть нашу последовательность. Напишем функцию, возвращающую список нескольких первых элементов (по умолчанию, шести):

\label{lazy-list}
\begin{Definition}[emph={str,n}]
(:: show ((Stream Any) (? Nat) -> list?)
 (define show
   (/. str   --> (show str 6)
       str 0 --> '()
       '() n --> '()
       (cons h t) n --> (cons h (show (force t) (- n 1)))))
\end{Definition}
Первое правило этой подстановки указывает, какое значение счётчика использовать по умолчанию. Следующие два правила завершают формируемый список в случае окончания потока или обнуления счётчика, третье~--- переписывает поток в список, по очереди вычисляя его элементы.

\begin{Assignment}
Напишите определения следующим функциям для работы с~потоками:

\fun{stream}{. x}~--- конструктор потока, подобный конструктору списка \s{list};
\begin{Specification}
(test 
  (stream)              ==> '()
  (show (stream 1))     ==> '(1)
  (show (stream 1 2 3)) ==> '(1 2 3))
\end{Specification}

\label{lazy-filter}\fun{filter~}{p s}, --- возвращает поток элементов \lex{s}, удовлетворяющих условию \lex{p};

\fun{until}{p s}, --- возвращает поток элементов \lex{s} до тех пор, пока для них не выполнится условие \lex{p};

\begin{Specification}
(test
  (show (until (= 4) (enum 1)))       ==> '(1 2 3)
  (show (until odd? (stream 2 4 6)))  ==> '(2 4 6)
  (show (until even? (stream 2 4 6))) ==> '())
\end{Specification}

\fun{map~}{f s \ddd}~--- применяет функцию \lex{f} к~элементам одного или нескольких потоков и~создаёт поток результатов;

\begin{Specification}
(test
  (show (map~ sqr (enum 1)))          ==> '(1 4 9 16 25 36)
  (show (map~ + (enum 1) ones))       ==> '(2 3 4 5 6 7)
  (show (map~ + ones (stream 1 2 3))) ==> '(2 3 4))
\end{Specification}

\end{Assignment}


\section{Комбинирование потоков}%
Пока наши потоки не~очень сильно отличались от~списков. Но с~потоками можно обращаться и~нестандартным образом.

Рассмотрим задачу суммирования элементов потока, то есть по~заданному потоку \s{(a b c ...)} построим поток последовательных сумм его элементов: \s{(a a+b a+b+c ...)}. Её можно решить следующим образом: будем многократно складывать исходный поток со~сдвигом:
\begin{SchemeCode}
  a  b  c  d  e $\cdots$
+    a  b  c  d $\cdots$
+       a  b  c $\cdots$
$\vdots$       $\vdots$
= a a+b a+b+c $\cdots$
\end{SchemeCode}

Реализуем это решение в~виде следующей функции:

\begin{Definition}[emph={s}]
(:: sum~ ((Stream Num) -> (Stream Num))
 (define (sum~ s)
   (map~ + s (cons~ 0 (sum~ s)))))
\end{Definition}

\noindent Так как потоки имеют бесконечную длину, добавление элемента не~помешает нам их складывать.

\newpage
\begin{Assignment}

a) Напишите обобщённую функцию аккумуляции для работы с~потоками:\fun{accumulate~}{f $x_0$ s} по~образцу функции \s{sum~}.

\begin{Specification}
(test 
  (show (accumulate~ + 0 ones))           ==> '(1 2 3 4 5 6)
  (show (accumulate~ - 0 ones))           ==> '(1 0 1 0 1 0)
  (show (accumulate~ + 0 (stream 1 2 3))) ==> '(1 3 6))
\end{Specification}

Создайте с помощью функции \s{accumulate~} последовательность факториалов натуральных чисел.

б) Определите поток чисел Фибоначчи $0,1,1,2,3,5,8,13,...$, пользуясь следующим свойством этого потока:
$$
\begin{array}{ccccccccc}
  & 1 & 1 & 2 & 3 & 5 & 8 & 13 & \ddd\\
+\\
  & 0 & 1 & 1 & 2 & 3 & 5 & 8 & \ddd\\
=\\
  & 1 & 2 & 3 & 5 & 8 & 13 & 21& \ddd\\
\end{array}
$$
То есть, поток чисел Фибоначчи есть поток, начинающийся с~0 и~1, такой, что остаток потока порождается сложением его с~собой самим, сдвинутым на~одну позицию.
\end{Assignment}

\section{Организация потока ввода}%
Чтобы показать, что использование потоков выходит за рамки чистой математики, приведём практический пример и~покажем, каким образом можно организовать поток данных, считываемых из какого-либо порта (файла или сетевого порта).

Язык \Scheme, как и полагается языку высокого уровня и широкого применения, имеет богатый инструментарий для работы с файлами. Мы же притворимся сейчас, что умеем только открывать файл и считывать оттуда отдельные знаки. Для этого нам понадобится функция \bfun{open-input-file}{name}, открывающая для чтения файл с именем \lex{name} и возвращающая соответствующий порт, а так же функция \bfun{read-char}{port}, читающая знак из указанного порта. 

Поставим перед собой задачу организовать поток чтения слов из файла. Решать её будем следующим образом. Сначала построим поток знаков, потом будем выбирать из него части, разделенные знаком-разделителем, например, пробелом, и организуем поток этих частей.

Начнём с создания потока знаков из заданного порта. Самым простым будет следующее решение:
\begin{Definition}[emph={p}]
(:: chars (port? -> (Stream char?))
  (define (chars p) 
    (until eof-object? 
           (cons~ (read-char p) (chars p)))))
\end{Definition}
\noindent
В результате мы получим поток знаков, считываемых из порта, ограниченный символом \s{eof}.
Назначение предиката \s{eof-object?} вполне очевидно --- он определяет конец файла. Предикат \s{char?} в сигнатуре функции определяет множество знаков ASCII или Unicode. Они обозначаются в \Scheme с помощью служебных символов \s{#\}. Например, знак \texttt{"a"} (код \s{97}) обозначается, как \s{#\a}. 

Давайте удостоверимся в том, что всё работает. Создадим в текущей директории текстовый файл \texttt{sample.txt} с таким содержанием:
\vspace{-\bigskipamount}
\begin{SchemeCode}
one two three four five six seven eight nine ten
\end{SchemeCode}
\noindent
Теперь откроем этот файл и прочитаем часть потока знаков из~него.
\REPLin{(define ch (chars (open-input-file "sample.txt")))}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}

Мы уже говорили о том, что операции ввода-вывода нарушают чистоту функционального языка, а это значит, что для одних и тех же данных они могут вернуть различные результаты. Проверим, так ли это в нашем случае?
\REPL{(show ch)}{(#\\o #\\space #\\t #\\h #\\r #\\e)}
\REPL{(show ch)}{(#\\o #\\space #\\f #\\o #\\u #\\r)}
Результат неожиданный и абсурдный, поскольку мы запрашиваем первые шесть символов \emph{уже сформированного} потока \s{ch}, повторный запрос ничего изменить не должен!

Для того, чтобы разобраться, придётся восстанавливать действие программы по шагам, поскольку, использование разрушающих функций возвращает нас в императивную парадигму.
\begin{enumerate}
\item При создании потока \s{ch} мы выполнили один раз функцию \s{read-char}, сформировав голову этого потока. Она уже меняться не будет, поэтому первый знак \s{#\o} при повторных вызовах не меняется.
\item При считывании последующих элементов потока мы вновь и вновь обращаемся к функции  \s{read-char} и меняем состояние порта (смещаем указатель на текущую позицию в файле).
\end{enumerate}
Все эти неприятности не означают, провала функциональной парадигмы и отказа от принципов чистоты при использовании ввода-вывода. Достаточно только сделать так, чтобы задержанные вычисления мемоизировались, тогда повторный вызов \emph{уже вычисленного} однажды выражения не будет приводить к повторному вызову разрушающей функции. Для чистых функций мемоизация только даст выигрыш во времени вычислений, а для функций имеющих побочный эффект, позволит <<спрятать>> их разрушающее действие.

Всё, что нам нужно сделать для решения вставшей проблемы,~--- это добавить мемоизацию в определение формы \s{delay}:
\begin{Definition}
(define-syntax-rule (delay expr)
  (delayed (memoized (lambda () expr))))
\end{Definition}
Больше ничего изменять не потребуется. Теперь всё работает, как надо: повторное обращение к конструктору потока \s{chars} приводит к смещению указателя на текущую позицию в файле, в то время как повторное выделение первых десяти элементов уже сформированного потока \s{ch} даёт одинаковые результаты.

\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}

Имея поток символов можно приступить к выделению из этого потока отдельных слов, разделённых пробелами.
\begin{Definition}
(:: words (port? -> (Stream Str))
  (define (words p) 
    (until (equal? "")
           (cons~ (chars->string (until (equal? #\space) 
                                        (chars p)))
             (words p)))))

(:: chars->string ((Stream char?) -> Str)
  (define (chars->string s) 
    (apply string (show s +inf.0))))
\end{Definition}
\newpage
Здесь функция \s{chars->string} преобразует конечный поток знаков в строку, используя базовый конструктор строки \sbi{string}. 

Проверим, что мы получили желаемый результат:
\REPLin{(define w (words (open-input-file "sample.txt")))}
\REPL{(show w)}{'("one" "two" "three" "four" "five" "six")}

Пусть нам нужно отыскать в файле слова, начинающиеся на букву "t". Для этого мы можем использовать фильтр потоков \s{filter~} (см. Задание~\ref{lazy-filter} на стр.~\pageref{lazy-filter}).
\begin{SchemeCode}
> (define w (words (open-input-file "sample.txt")))
> (filter~ (regexp-match? #rx"^r") w)
\end{SchemeCode}

Чего же мы добились использованием потоков? Во-первых, мы создали интерфейс, адекватный процессу последовательного чтения данных из файла и пригодный для обработки универсальными инструментами, оперирующими с потоками.
Во-вторых, мы получили возможность оборвать процесс чтения в любом месте, когда нам это понадобится. Причём это решение мы принимаем не в процедуре низкоуровневого чтения файла, а на самом верхнем уровне – на стадии формулировки задачи. 

\begin{Assignment}
Напишите определение для функциии \s{(read-word p)}, которая работала бы подобно функции \s{read-char}, но считывала из файла отдельные слова. Убедитесь в том, что эта функция имеет побочный эффект. Перепишите функцию \s{words}, используя \s{read-word}.
\end{Assignment}


\section{Ленивые~вычисления за~пределами~\Scheme}%
Отложенные вычисления в~том или ином виде встречаются, как в~функциональных языках, так и~в нефункциональных. В~языках, имеющих анонимные функции можно реализовать отложенные вычисления по~тому же принципу, что мы показали для \Scheme~--- с~помощью функций без~аргументов, задерживающих вычисление своего тела (санков). В~большинстве языков (и в~базовой реализации \s{delay} и~\s{force} в~\Scheme) при~этом происходит запоминание уже полученных результатов~--- мемоизация. Это существенно повышает эффективность ленивых программ.

В языке \Lang{Mathematica} различают непосредственные замены (присваивания) и~замены (присваивания) с~задержкой, имитирующие ленивые вычисления.

Существуют языки программирования, в~которых все вычисления ленивы (\Lang{Miranda}, \Lang{Haskell}, \Lang{Lazy Scheme} и~др.). Это позволяет работать с~любыми списками, как с~потоками, и~использовать для потоков такую удобную и~мощную абстракцию, как \emph{list comprehension}, позволяющую давать лаконичные и~очень выразительные описания списков.

\begin{Queeze}

 \item В чём состоит отличие аппликативного и~нормального порядка вычисления? Какой порядок вычисления используется для функций в~\Scheme?

 \item Для каких синтаксических конструкций языка \Scheme нарушается аппликативный порядок вычислений?

 \item Как создать макрос в~\Scheme? Как его можно использовать? Когда будет выполняться вызов макроса?

 \item Зачем нужны отложенные вычисления?

 \item В~чём состоит назначение формы \s{delay} и~функции \s{force} языка \Scheme? Как их можно было бы реализовать?

 \item Что такое отложенный список? Какие новые возможности даёт использование отложенных списков?

 \item Приведите пример простой функции и~её вызова, для которой нормальнаный порядок вычисления требовал бы меньшего количества элементарных операций, чем аппликативный.

 \item Приведите пример простой функции и~её вызова, для которой аппликативный порядок вычисления требовал меньшего количества элементарных операций, чем нормальный. Изучите на~этом примере возможность повышения эффективности нормального порядка вычислений за~счёт мемоизации.

\end{Queeze}
