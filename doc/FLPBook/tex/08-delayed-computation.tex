%!TEX root = main.tex
\Lesson{Отложенные вычисления}\label{Less:delayed-computation}

\section[4]{Аппликативный и~нормальный порядок вычисления}%
\label{normal-order}Мы уже рассказывали, каким образом интерпретатор \Scheme вычисляет выражения: сначала вычисляются оператор и~операнды, а~затем получившаяся процедура применяется к~получившимся аргументам (см. Занятие \ref{Less:functions}, стр.\,\pageref{applicative-order}).

Существует и~другая модель, в~которой вычисление аргументов не~производится до~тех пор, пока не~понадобится их значение. Вместо этого в~функцию подставляются выражения-операнды, до~тех пор пока не~получится выражение, в~котором присутствуют только элементарные операторы, и~лишь затем производится вычисление всего выражения. Этот второй метод известен под~названием \index{порядок вычисления!\emph{нормальный}}\emph{нормальный порядок вычислений}.

Вычисления, основывающиеся на~аппликативном порядке называются \index{вычисления!интенсивные}\emph{интенсивными}, а~на нормальном~--- \index{вычисления!ленивые}\emph{ленивыми}. Существуют \index{языки программирования!\emph{ленивые}}\emph{ленивые языки программирования} в~которых используется только нормальный порядок вычислений. Ярким примером таких языков является язык \Lang{Haskell}.

\section[2]{Специальные формы}\index{специальная форма}%
В языке \Scheme преимущественно используется аппликативный порядок. Но никакой язык программирования не~сможет обойтись только им. 

Рассмотрим, для примера, как выполняется конструкция ветвления \s{(if test? P${}_1$ P${}_2$)}. В~зависимости от~результата процедуры \s{test?}, может быть выполнена либо процедура \s{P${}_1$} либо \s{P${}_2$}. Нам незачем сначала вычислять и~ту и~другую ветвь с~тем, чтобы выбрать результат одной из~них. Поэтому вычисление формы \s{if} не~должно подчиняться аппликативному порядку. 

Мы называем \s{if} или~\s{cond} не~функциями, а~\emph{специальными формами}~--- то есть конструкциями языка с неаппликативным порядком вычисления. Специальные формы сначала оперируют переданными им в~качестве аргументов выражениями, не~вычисляя их, и~только затем проводят вычисления, если это необходимо.

В~виде специальных форм определены и~логические операции \s{or} и~\s{and}. К~специальным формам относятся также \s{define} и~\s{lambda}~--- тела функций, которые описываются с~их помощью, не~должны вычисляться прежде, чем эти функции будут вызваны.


\section[2]{Макросы}\index{макрос}\label{macro}%
Возможность вводить в~язык \Scheme специальные формы обеспечивается механизмом \emph{макросов}. Макрос описывает \emph{синтаксическое преобразование выражения без~его вычисления}. \Scheme имеет чрезвычайно богатые средства для макропрограммирования.  

Здесь мы не~будем подробно останавливаться на~технике написания макросов, а~только укажем, как можно создать простейшую специальную форму с~их помощью. В~самом простом случае, описание макроса с именем \lex{name} имеет следующий вид:

\bsfindex{define-syntax-rule}
\begin{Specification}[emph={name,pat}]
(define-syntax-rule (name pat)
    body)
\end{Specification}

\noindent Здесь \lex{pat}~--- образец трансформируемой формы. В~элементарном случае, он может быть оформлен, подобно тому, как это делается в~определениях с~помощью формы \s{define}. Выражение \s{body} представляет собой выходное выражение, в~которое трансформируется форма.

Вот, например, определение простейшей формы \si{or}, выполненное с~помощью макроса:

\sfindex{or}
\begin{Definition}[emph={x,y}]
(define-syntax-rule (or x y)
  (if x x y))
\end{Definition}

Это определение предписывает выражение \s{(or x y)} переписать, как \s{(if x x y)}. Именно \emph{переписать} и~только потом вычислить. Основное отличие макроса от~обыкновенной функции и~состоит в~том, что его трансформация происходит до~начала выполнения программы. При~этом не~используются никакие связывания, возникающие во~время исполнения программы. Такой подход, характерный для языка \Lang{Scheme}, получил название «гигиеничный макрос».

\section{Когда использовать макросы?}%
Макропрограммирование позволяет существенно расширять синтаксис языка, добавляет ему выразительности и~делает его более предметно ориентированным. Однако, если какие-то из~этих задач можно решить с~помощью функций, стоит использовать функции.

\index{объект первого класса}Важным отличием синтаксической формы от~функции является то, что формы \emph{не являются объектами первого класса} языка \Scheme. Их невозможно комбинировать с  другими функциями. Для этого специальные формы приходится «прятать» внутрь функций.

Кроме того, как мы уже говорили, макросы позволяют обходить аппликативный порядок вычислений, это полезно, но только если это происходит осознанно, и~оправдано постановкой задачи. В~противном случае, нарушается стройность и единообразие функционального подхода, обеспечивающие его гибкость и расширяемость. К тому же, злоупотребление макросами может существенно затруднить анализ и отладку программы.

Таким образом, можно сказать, что макросы нужно применять только тогда, когда без~них обойтись невозможно.

\section{Отложенные вычисления}%
\label{delay}Несмотря на~то, что \Scheme не~является ленивым языком, мы можем расширить его так, что нам станут доступны некоторые приёмы ленивых вычислений.

\index{вычисления!отложенные}\emph{Отложенные вычисления} базируются на~том, что мы можем задержать вычисление того или иного выражения до~тех пор, пока это нам не~потребуется. Основой для реализации отложенных вычислений будут форма \s{(~ expr)}, оставляющая выражение \s{expr} невычисленным, и~функция \si{!}, которая вынуждает произвести задержанное вычисление.
\label{lazy}Вот, пример простейшей реализации этой пары:

\begin{Definition}
(define-syntax-rule (~ expr)
  (lambda () expr))

(define (! expr) (expr))
\end{Definition}

Вычисления задерживаются с помощью \lmфункции. Здесь мы пользуемся тем, что \lmфункция не~вычисляет своё тело до~тех пор, пока она не~будет вызвана с~каким-либо аргументом. А~функция \s{(lambda () expr)} не~будет требовать никаких аргументов. Такую структуру называют термином \emph{санк}\index{санк} (англ. \emph{thunk}). Функция \s{!} \emph{вычисляет} эту функцию, вызывая её без аргументов.

Покажем, зачем могут понадобиться ленивые вычисления, на~примере обобщения рекурсивного обхода списка в~виде свёртки. Недостатком свёртки является то обстоятельство, что независимо от~необходимости, список проходится полностью. Тогда, как, например, для функции \fun{any}{test? lst}, проверяющей, есть ли в~списке \lex{lst} элементы, удовлетворяющие условию \lex{test?}, следовало бы остановить поиск, как только найдётся первый подходящий элемент. Вот каким образом мы можем определить эту функцию через свёртку:

\begin{Definition}[emph={el,res,test?,lst}]
(define/c (any test?)
  (foldr (lambda (el res) (or (test? el) res)) #f))
\end{Definition}

Свёртка~--- достаточно мощная и~удобная абстракция, и~отказываться от~неё не~хотелось бы. Вместо этого, модифицируем её, определив ленивую свёртку\index{свёртка!ленивая}\fnindex{foldr~}:

\begin{Definition}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
 (define/c (foldr~ f $x_0$)
   (/. '() --> $x_0$
       (cons h t) --> (f h (~ (foldr~ f $x_0$ t))))))
\end{Definition}
Определяя функцию \s{foldr~}, мы с~помощью формы \s{~} задерживаем рекурсию, откладывая на~потом вычисление второго аргумента функции \lex{f}.

Посмотрим, как воспользоваться ленивой свёрткой, для определения функции \s{any?}:

\begin{Definition}[emph={test?,lst,el,res}]
(define/c (any~ test?)
  (foldr~ (lambda (el res) (or (test? el) (! res))) #f))
\end{Definition}
Теперь вычисление второго аргумента сворачивающей \lmфункции происходит только тогда, когда тест для очередного элемента не~выполняется. Если же тест пройден успешно, форма \s{or} возвращает \s{#t} и~рекурсия заканчивается.
\newpage

\begin{Assignment}
Так как мы работаем в рамках чистого функционального программирования, поведение функций \s{any} и \s{any~} будет неотличимым: на одинаковых данных они всегда возвращают одинаковый результат, так что тесты не выявят разницы в вычислительном процессе. Чтобы убедиться в том, что ленивый вариант действительно ленив, нужно добавить какой-либо побочный эффект, например, вывод промежуточных результатов. 

Напишите простой оператор \fun{verbose}{f}, преобразующий любую функцию \lex{f} в <<говорящую>>:
\REPLin{((verbose +) 1 2)}\vspace{-\smallskipamount}
\REPLout{ (+ 1 2)}
\REPLout{3}
\REPLin{(map (verbose sqr) '(2 4 5)}\vspace{-\smallskipamount}
\REPLout{ (sqr 2)}\vspace{-\smallskipamount}
\REPLout{ (sqr 4)}\vspace{-\smallskipamount}
\REPLout{ (sqr 5)}
\REPLout{'(4 16 25)}

С её помощью убедитесь в том, что функция \s{any~}, в отличие от \s{any}, завершает работу вовремя.

\end{Assignment}

\section[2]{Ленивая свёртка}%
Построенная нами абстракция ленивой обработки списка имеет существенный недостаток:
для того, чтобы ею воспользоваться, пришлось в определении функции \s{any~} переписывать сворачивающую \lmфункцию, использовать внутри неё функцию \s{!} и задействовать особые свойства формы \s{or}. Между абстракцией и функцией её использующей должен выстраиваться \emph{барьер абстракции}: функция \s{foldr} <<знает>>, как устроен список, когда он заканчивается и как получить доступ к его частям. Функция \s{any} <<знает>> что она ищет, и ей неважно, как устроен список; <<низкоуровневые>> функции \s{cons}, \s{car} и \s{cdr} находятся на другом уровне абстракции и скрыты от неё. В нашем случае, функция \s{!} явно принадлежит более низкому уровню абстракции, чем функция \s{any}, а знание особых свойств формы \s{or}, отражают необходимость знать, как именно работает функция \s{foldr~}. В таких случаях говорят об утечке абстракции (leaky abstraction).

Этого можно избежать, если ленивую свёртку организовать следующим образом:

\label{lazy-fold}
\begin{Definition}[emph={f,lst,h,t}]
(:: foldr~ ((Any Any -> Any) Any list? -> Any)
  (define/c (foldr~ f $x_0$)
    (/. '() --> $x_0$
        (cons h t) --> (! (f h (~ (foldr~ f $x_0$ (! t))))))))
\end{Definition}

\noindent
В новом определении свёртки <<внутренний>> \s{!} запускает рекурсивный вызов, а <<внешний>> --- продолжает вычисления, если функция \lex{f} возвращает задержанный второй агрумент. Такое решение обеспечивает большую модульность, поскольку вся информация о характере вычислений сосредотачивается в функции свёртки.

Однако, для того, чтобы новое определение свёртки заработато, нужно немного изменить определение для функции \s{!}. Дело в том, что ленивая свёртка может возвращать задержанное значение, которое будет ещё раз задержано перед рекурсивным вызовом, и одного применения функции \s{!} для запуска рекурсии не хватит. Чтобы такое многократное задерживание не помешало, сделаем так, чтобы функция \s{!} продолжала вычислять задержанные выражения до тех пор, пока они не перестанут быть задержанными. Для этого нам необходимо отличать задержанные вычисления от любых других. Ниже приводится усовершенствованная реализация формы \s{~} и функции \s{!}, использующая для создания  
абстрактного типа для задержанных вычислений формальную функцию.
\begin{Definition}
(define-formal (delayed 1))

(define-syntax-rule (~ expr)
  (delayed (lambda () expr)))

(define !
  (//. (delayed? expr) --> (expr)))
\end{Definition}
\noindent
Если выражение не является задержанным, подстановка в определении функции \s{!} вернёт его без изменений, а задержанное --- вычислит столько раз, сколько потребуется.

Теперь можно будет использовать определение функции \s{any~}, не отличающееся от неленивого:
\begin{SchemeCode}[emph={el,res,test?,lst}]
(define/c (any test?)  (foldr  ($\circ$ or test?) #f))
(define/c (any~ test?) (foldr~ ($\circ$ or test?) #f))
\end{SchemeCode}
Видно, что вся информацию о характере вычислений сосредоточена в функции свёртки. Кроме того, стало возможным использовать \s{or}, как функцию, не полагаясь на какие-либо исключения из общих правил вычисления функций.
Кроме того, функция \s{foldr~} является примером построения \emph{стандартного интерфейса}, позволяющего использовать функции с сходной семантикой сходным образом.

\section[2]{Потоки данных}%
\index{отложенные списки}%
\index{поток}%
Итак, мы построили ленивый аналог для свёртки списка, а значит, с её помощью можно определить ленивые аналоги для всех функций, определённых в главе \ref{Less:fold}. Давайте посмотрим, что мы получим в результате ленивого отображения списка:
\begin{Definition}
(define/c (map~ f) (foldr~ ($\circ$ cons f) '())) 
\end{Definition}
\REPLin{(define s (map~ (hold 'f) '(a b c)))}
\REPL{s}{'((f a) delayed <#procedure>)}
Вычисленным оказалась только голова полученного списка, вычисление хвоста пока осталось задержанным. Попробуем вычислить хвост:
\REPL{(! (cdr s))}{'((f b) delayed <#procedure>)}
Получили второй элемент списка и вновь здержанное выражение в качестве хвоста. Таким образом, функция \s{map~} возвращает последовательность пар с задержанными вторыми элементами:
\begin{SchemeCode}
((f a) . (~ ((f b) . (~ ((f c) . (~ null))))))
\end{SchemeCode}
Такая структура называется \emph{ленивым списком}, или \emph{потоком}~--- последовательностью данных, каждый элемент которой вычисляется по требованию. Это очень полезная структура, позволяющая изящно решать самые разнообразные задачи.

Поток устроен так же, как и~обыкновенный список~--- в~виде последовательности вложенных точечных пар. Эти две структуры подобны, а значит можно организовать для потока стандартный интерфейс: конструктор и селекторы

\label{lazy-cons}Вот один из возможных вариантов реализации конструктора и селекторов для потока, назовём их, соответственно \s{cons~}\sfindex{cons~}, \s{car~} и~\s{cdr~}:

\newpage
\begin{Definition}[emph={h,t}]
(define-syntax-rule (cons~ h t)
 (cons h (~ t)))

(:: car~ (pair? -> Any)
 (define (car~ s) (car s)))

(:: cdr~ (pair? -> Any)
 (define (cdr~ s) (! (cdr s))))
\end{Definition}

Конструктор \s{cons~} должен быть формой, а не функцией, поскольку он не должен задержать вычисление своего второго аргумента. Функция \s{car~} просто возвращает первый элемент пары, а~функция \s{cdr~} \emph{вычисляет} второй элемент с~помощью функции \s{!}. Таким образом, вычисление второго элемента будет происходить только при~вызове \s{cdr~}.

\begin{example}{Попробуем составить какую-нибудь пару. Как и~ожидалось, вторым её элементом является задержанная функция, а~\s{cdr~} от~нашей пары вынуждает провести отложенные вычисления.}
\REPLin
  {(define x (cons~ 1 2))}
\REPL
  {x}
  {(1 delayed \#<procedure>)}
\REPL
  {(car~ x)}
  {1}
\REPL
  {(cdr~ x)}
  {2}
\end{example}

А теперь давайте воспользуемся нашими достижениями для следующего сомнительного определения:

\begin{Definition}
(define ones (cons~ 1 ones))
\end{Definition}

Если бы мы следовали подстановочной модели с~аппликативным порядком вычислений, то незамедлительно получили бы бесконечную рекурсию или сообщение об~ошибке. Однако, в~случае отложенных пар мы описали нечто вполне осмысленное. Посмотрим, что мы получим, вычисляя \s{ones} и~его части:

\REPL
  {ones}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ ones)}
  {(1 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ ones))}
  {(1 delayed \#<procedure>)}
\newpage%
\noindent%
Сколько бы раз мы ни~вычисляли \s{cdr~} от~пары \s{ones}, мы всегда будем получать один и~тот же результат и~никогда не~достигнем какого-либо конца. Эффективно, \s{ones} ведёт себя, как \emph{бесконечная} последовательность (поток) единиц: \s{(1 . (1 . (1 . ...)))}!

Мы будем считать концом потока (если он не~бесконечен), объект \s{null}, также, как для списков. Дадим определение полиморфного алгебраического типа для потока:

\begin{Definition}
(define-type (Stream A)
  '()
  (cons: A delayed?))
\end{Definition}
\REPL{(is ones (Stream 1))}{#t}

\noindent%
Приведём ещё один пример бесконечного потока:

\begin{Definition}[emph={n}]
(:: enum (Num -> (Stream Num))
 (define (enum n) 
   (cons~ n (enum (+ n 1)))))
\end{Definition}

\REPL
  {(enum 1)}
  {(2 delayed \#<procedure>)}

\REPL
  {(cdr~ (enum 1))}
  {(3 delayed \#<procedure>)}

\REPL
  {(cdr~ (cdr~ (enum 1)))}
  {(4 delayed \#<procedure>)}

Поток \s{(enum $n$)} описывает арифметическую прогрессию с шагом~1, начинающуюся с~$n$.

Создадим способ увидеть нашу последовательность. Напишем функцию, возвращающую список нескольких первых элементов (по умолчанию, шести):
\begin{Definition}[emph={str,n}]
(:: show ((Stream Any) (? Nat) -> list?)
 (define show
   (/. str   --> (show str 6)
       str 0 --> '()
       '() n --> '()
       (cons h t) n --> (cons h (show (! t) (- n 1))))))
\end{Definition}
Первое правило этой подстановки указывает, какое значение счётчика использовать по умолчанию. Следующие два правила завершают формируемый список в случае окончания потока или обнуления счётчика, третье~--- переписывает поток в список, по очереди вычисляя его элементы.

\begin{Assignment}
а) Напишите определения для следующих последовательностей:
\begin{enumerate}
\item \s[emph={a,s}]{(aryph a s)} --- арифметическая последовательность с заданным шагом: $$a, a+s, a+2s, ...;$$
\item \label{iteration}\s[emph={f}]{(iteration f x)} --- последовательность аппликаций заданной функции: $$x, f(x), f(f(x)), ...;$$
\item \s{(powers x)} --- последовательность степеней заданного числа: $$1, x, x^2 , x^3, \ddd .$$
\end{enumerate}


б) Напишите определения следующим функциям для работы с~потоками, используя, где это возможно, ленивую свёртку.

\fun{stream}{. x}~--- конструктор потока, подобный конструктору списка \s{list};
\begin{Specification}
(test 
  (is (stream 1 2 3) (Stream Int))
  (stream)              ==> '()
  (show (stream 1))     ==> '(1)
  (show (stream 1 2 3)) ==> '(1 2 3))
\end{Specification}

\fun{cycle}{a b ...}~--- конструктор цикла $a,b,...,a, b,...$
\begin{Specification}
(test 
  (cycle)              ==> '()
  (show (cycle 1))     ==> '(1 1 1 1 1 1)
  (show (cycle 1 2 3)) ==> '(1 2 3 1 2 3))
\end{Specification}


\label{lazy-filter}\fun{filter~}{p s}, --- возвращает поток элементов \lex{s}, удовлетворяющих условию \lex{p};

\label{until}\fun{proceed-while}{p s}, --- возвращает поток элементов \lex{s}, пока для них выполняется условие \lex{p};

\begin{Specification}
(test
  (show (proceed-while (negated (= 4)) (enum 1))) ==> '(1 2 3)
  (show (proceed-while even? (stream 2 4 6)))     ==> '(2 4 6)
  (show (proceed-while odd? (stream 2 4 6)))      ==> '())
\end{Specification}

\label{until}\fun{skip-until}{p s}, --- опускает элементы потока \lex{s}, пока для них впервые не выполнится условие \lex{p};

\fun{compose~}{f $s_1$ $s_2$ \ddd}~--- применяет функцию \lex{f} к~элементам двух или более потоков и~создаёт поток результатов;

\begin{Specification}
(test
  (show (compose~ + (enum 1) ones))       ==> '(2 3 4 5 6 7)
  (show (compose~ + ones (stream 1 2 3))) ==> '(2 3 4))
\end{Specification}
\end{Assignment}

\section[4]{Пример: решение дифференциального уравнения}%
Рассмотрим часто встречающуюся задачу прикладной математики --- численное решение обыкновенных дифференциальных уравнений. Формулировка задачи такова: для заданного уравнения вида $y'=f(x,y)$ и начальных условий $y(x_0)=y_0$ построить таблицу (график) его решения.

Самым простым методом численного решения обыкновенных дифференциальных уравнений является метод Эйлера. Он состоит в последовательном вычислении значений функции $y_n$ на равномерной сетке $x_n = x_0 + n h, n = 0,1,2,...$, согласно соотношению:
$$y_{n+1} &= y_n + h f(x_n,y_n).$$

Это соотношение мы запишем в виде функции:
\begin{Definition}[emph={f,x,y,h}]
(:: euler (Num (Num Num -> Num) Num Num -> Num))
  (define (euler h f x y)
    (+ y (* h (f x y)))))
\end{Definition}

Решим, например, следующее уравнение с шаном 0.1:
$$y'=-x y,\quad y(0)=1.$$

\begin{SchemeCode}
(define x (aryth 0 0.1))

(define y (cons~ 1 (compose~ (euler 0.1 f) x y)))
\end{SchemeCode}
\REPL{(show y)}{'(1 1 0.99 0.9702 0.941094 0.90345024)}
\noindent%
Мы получили потенциально бесконечную последовательность, представляющую численное решение данной задачи.

Для того, чтобы ограничить эту последовательность каким-либо отрезком на оси $x$, можно написать функцию \s{select-by}, выбирающую из потока часть, удовлетворяющую некоторому условию:
\begin{Definition}
(define (select-by p s)
  (proceed-while p (skip-until p s)))
\end{Definition}


\begin{Assignment}


\end{Assignment}

\section{Пример: Организация потока ввода}%
Чтобы показать, что использование потоков выходит за рамки чистой математики, приведём практический пример и~покажем, каким образом можно организовать поток данных, считываемых из какого-либо порта (файла или сетевого порта).

Язык \Scheme, как и полагается языку высокого уровня и широкого применения, имеет богатый инструментарий для работы с файлами. Мы же притворимся сейчас, что умеем только открывать файл и считывать оттуда отдельные знаки. Для этого нам понадобится функция \bfun{open-input-file}{name}, открывающая для чтения файл с именем \lex{name} и возвращающая соответствующий порт, а так же функция \bfun{read-char}{port}, читающая знак из указанного порта. 

Поставим перед собой задачу организовать поток чтения слов из файла. Решать её будем следующим образом. Сначала построим поток знаков, потом будем выбирать из него части, разделенные знаком-разделителем, например, пробелом, и организуем поток этих частей.

Функция \s{read-char}, считывая очередной знак, смещает указатель на текущую позицию в файле, а это значит, что повторный её вызов приведёт к считыванию нового знака. Эта функция имеет побочный эффект и не является чистой, что свойственно операциям ввода-вывода, но нарушает функциональность программы. Именно поэтому целесообразно организовать считывание данных из файла в виде потока. Можно представить себе, что поток --- это просто список с элементами, совпадающими с содержимым файла. Так как списки и потоки функционально эквивалентны, нам неважно, откуда берётся очередной элемент списка --- получается по ссылке из памяти, или генерируется функцией с побочным эффектом.

Поток знаков мы организуем так же, как и поток единиц \s{ones}:
\begin{SchemeCode}[emph={p}]
(define (chars p) (cons~ (read-char p) (chars p))))
\end{SchemeCode}
А чтобы ограничить его концом файла, используем функцию \s{until} (см. Задание~\ref{until}, стр. \pageref{until}) и получим окончательный вариант:
\begin{Definition}[emph={p}]
(:: chars (port? -> (Stream char?))
  (define (chars p) 
    (until eof-object? 
           (cons~ (read-char p) (chars p)))))
\end{Definition}
\noindent
Назначение предиката \s{eof-object?} вполне очевидно --- он определяет конец файла. Предикат \s{char?} в сигнатуре функции определяет множество знаков ASCII или Unicode. Они обозначаются в \Scheme с помощью служебных символов \s{#\}. Например, знак \texttt{"a"} (код \s{97}) обозначается, как \s{#\a}. 

Давайте удостоверимся в том, что всё работает. Создадим в текущей директории текстовый файл \texttt{sample.txt} с таким содержанием:
\vspace{-\bigskipamount}
\begin{SchemeCode}
one two three four five six seven eight nine ten
\end{SchemeCode}
\noindent
Теперь откроем этот файл и прочитаем часть потока знаков из~него.
\REPLin{(define ch (chars (open-input-file "sample.txt")))}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}

Мы уже говорили о том, что операции ввода-вывода нарушают чистоту функционального языка, а это значит, что для одних и тех же данных они могут вернуть различные результаты. Проверим, так ли это в нашем случае?
\REPL{(show ch)}{(#\\o #\\space #\\t #\\h #\\r #\\e)}
\REPL{(show ch)}{(#\\o #\\space #\\f #\\o #\\u #\\r)}
Результат неожиданный и абсурдный, поскольку мы запрашиваем первые шесть символов \emph{уже сформированного} потока \s{ch}, повторный запрос ничего изменить не должен! К тому же, почему-то изменяются все элементы потока, кроме первого.

Для того, чтобы разобраться, придётся восстанавливать действие программы по шагам, поскольку, использование разрушающих функций возвращает нас в императивную парадигму.
\begin{enumerate}
\item При создании потока \s{ch} мы выполнили один раз функцию \s{read-char}, сформировав голову этого потока. Она уже меняться не будет, поэтому первый знак \s{#\o} при повторных вызовах не меняется.
\item При считывании последующих элементов потока мы вновь и вновь обращаемся к функции  \s{read-char} и меняем состояние порта (смещаем указатель на текущую позицию в файле).
\end{enumerate}

Эти неприятности не означают, что наша затея с потоками провалилась. Достаточно только сделать так, чтобы задержанные вычисления мемоизировались, тогда повторный вызов уже вычисленного однажды выражения не будет приводить к повторному вызову разрушающей функции. На поведении чистых функций мемоизация не скажется (и даже даст выигрыш во времени вычислений), а для функций имеющих побочный эффект, позволит <<спрятать>> их разрушающее действие.

Всё, что нам нужно сделать для решения вставшей проблемы,~--- это добавить мемоизацию в определение формы \s{delay}:
\begin{Definition}
(define-syntax-rule (delay expr)
  (delayed (memoized (lambda () expr))))
\end{Definition}
Больше ничего в программе изменять не потребуется. Теперь всё работает, как надо: 
\REPLin{(define ch (chars (open-input-file "sample.txt")))}\vspace{-\smallskipamount}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}
\REPL{(show ch)}{'(#\\o #\\n #\\e #\\space #\\t #\\w)}
\newpage
\noindent
Повторное обращение к конструктору потока \s{chars} приводит к смещению указателя на текущую позицию в файле, в то время как повторное выделение первых десяти элементов уже сформированного потока \s{ch} даёт одинаковые результаты.

Имея поток символов, можно приступить к выделению из этого потока отдельных слов, разделённых пробелами. С помощью функции \s{read-char}, мы легко создали поток знаков. Разумно будет построить единообразный интерфейс и создать функцию \s{read-word}, считывающую из порта по одному слову. Тогда организация потока слов станет тривиальной задачей.
\begin{Definition}[emph={p,ch,s}]
(:: words (port? -> (Stream Str))
  (define (words p) 
    (until eof-object? 
           (cons~ (read-word p) (words p)))))
\end{Definition}

Посмотрим на возможную реализацию функции \s{read-word}:
\begin{Definition}[emph={p,ch,s}]
(:: read-word (port? -> ($\cup$ eof-object? Str))
  (define (read-word p)
    (let ([ch (chars p)])
      (if (empty? ch)
          eof
          (chars->string (until (equal? #\space) ch))))))

(:: chars->string ((Stream char?) -> Str)
  (define (chars->string s) 
    (apply string (show s +inf.0))))
\end{Definition}
\noindent
Функция \s{read-word} формирует поток знаков из указанного порта, а затем с помощью \s{until} выбирает из этого потока часть до первого пробела. Функция \s{chars->string} преобразует этот поток знаков в строку, используя базовый конструктор строки \sbi{string}. Поток слов завершается вместе с завершением потока знаков и возвращает символ конца файла \s{eof}.

Проверим, что мы получили желаемый результат:
\REPLin{(define w (words (open-input-file "sample.txt")))}
\REPL{(show w)}{'("one" "two" "three" "four" "five" "six")}

С потоком слов можно обращаться, как с любым другим потоком: преобразовывать его, фильтровать и т.д. Пусть, например, нам нужно отыскать в файле слова, начинающиеся на букву \s{"t"}. Для этого мы можем использовать фильтр потоков \s{filter~} (см. Задание~\ref{lazy-filter} на стр.~\pageref{lazy-filter}) и сопоставление в регулярным выражением \s{regexp-match?}.

\REPL
 {(show (filter~ (regexp-match? "^t") w))}
 {'("two" "three" "ten")}

Чего же мы добились использованием потоков? Во-первых, мы создали интерфейс, адекватный процессу последовательного чтения данных из файла и пригодный для обработки универсальными инструментами, оперирующими с потоками.
Во-вторых, мы получили возможность оборвать процесс чтения в любом месте, когда нам это понадобится. Причём это решение мы принимаем не в процедуре низкоуровневого чтения файла, а на самом верхнем уровне – на стадии формулировки задачи. 

Например, для того, чтобы получить только первое слово из файла, начинающееся на \s{"t"} мы наможем написать:
\REPL{(car~ (filter~ (regexp-match? "^t") w))}{''two''}

\noindent
При этом не нужно будет считывать весь файл --- обработка потока завершится, как только будет получен первый его элемент.

\begin{Assignment}
Сходство функций \s{chars} и \s{words} наводит на мысль о создании абстракции для порождения потоков с помощью \emph{генераторов} --- функций с побочным эффектом. Так чтобы можно было, например, написать такие определения:
\begin{SchemeCode}
(define chars (in-producer read-char))
(define words (in-producer read-word))
\end{SchemeCode}
Создайте с помощью этой абстракции поток случайных чисел, используя в качестве генератора функцию \s{random}. Что будет, если в качестве генератора использовать чистую функцию?
\end{Assignment}


\section{Ленивые~вычисления за~пределами~\Scheme}%
Отложенные вычисления в~том или ином виде встречаются, как в~функциональных языках, так и~в нефункциональных. В~языках, имеющих анонимные функции можно реализовать отложенные вычисления по~тому же принципу, что мы показали для \Scheme~--- с~помощью функций без~аргументов, задерживающих вычисление своего тела (санков). В~большинстве языков (и в~базовой реализации \s{delay} и~\s{!} в~\Scheme) при~этом происходит запоминание уже полученных результатов~--- мемоизация. Это существенно повышает эффективность ленивых программ.

В языке \Lang{Mathematica} различают непосредственные замены (присваивания) и~замены (присваивания) с~задержкой, имитирующие ленивые вычисления.

Существуют языки программирования, в~которых все вычисления ленивы (\Lang{Miranda}, \Lang{Haskell}, \Lang{Lazy Scheme} и~др.). Это позволяет работать с~любыми списками, как с~потоками, и~использовать для потоков такую удобную и~мощную абстракцию, как \emph{list comprehension}, позволяющую давать лаконичные и~очень выразительные описания списков.

\begin{Queeze}

 \item В чём состоит отличие аппликативного и~нормального порядка вычисления? Какой порядок вычисления используется для функций в~\Scheme?

 \item Для каких синтаксических конструкций языка \Scheme нарушается аппликативный порядок вычислений?

 \item Как создать макрос в~\Scheme? Как его можно использовать? Когда будет выполняться вызов макроса?

 \item Зачем нужны отложенные вычисления?

 \item В~чём состоит назначение формы \s{delay} и~функции \s{!} языка \Scheme? Как их можно было бы реализовать?

 \item Что такое отложенный список? Какие новые возможности даёт использование отложенных списков?

 \item Приведите пример простой функции и~её вызова, для которой нормальнаный порядок вычисления требовал бы меньшего количества элементарных операций, чем аппликативный.

 \item Приведите пример простой функции и~её вызова, для которой аппликативный порядок вычисления требовал меньшего количества элементарных операций, чем нормальный. Изучите на~этом примере возможность повышения эффективности нормального порядка вычислений за~счёт мемоизации.

\end{Queeze}
