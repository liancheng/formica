%!TEX root = main.tex
\Lesson{Функции высшего~порядка и~функционалы}\label{Less:high-order}

\section[4]{Абстракция вычислительного процесса}%
В предыдущих главах мы познакомились с приёмами, хоть и характерными для функционального программирования, но успешно используемыми и вне этого подхода. Рекурсия, абстрактные типы данных и символы используются в рамках самых разных парадигм. На этом занятии мы, наконец, займёмся <<настоящим>> функциональным программированием: оперированием, комбинированием и созданием функций. 

На первом занятии мы уже говорили, что функциональное программирование подразумевает использование функций, как объектов первого класса, значит их можно передавать в качестве аргументов другим функциям и получать в качестве результатов. Функция, принимающая в~качестве аргументов другие функции, называется \index{функция!высшего порядка}\emph{функцией высшего порядка}. Если функция возвращает функцию в~качестве результата, то мы будем её называть \index{функционал}\emph{функционалом}, или \index{оператор}\emph{оператором.} 

Мы уже рассматривали и~использовали функции высших порядков: \s{sum}, \s{bisection}, \s{accumulate}, \s{map} и~т.\,п. Некоторые из~них имеют достаточно узкое применение, другие используются очень широко, как универсальные инструменты. Последние являются \index{абстракция!процесса}\emph{абстракциями процессов}, обобщающими некоторые типичные вычислительные процессы. Например, функция \s{accumulate} является абстракцией итерации с~накоплением в~заданном диапазоне числового индекса, \s{map} абстрагирует отображение множества с~помощью заданной функции.

Позже мы рассмотрим ещё несколько полезных и~универсальных абстракций~--- свёртку (абстракцию структурной рекурсии), поиск неподвижной точки (к ней сводится, например, функция \s{bisection} и~вообще, произвольный рекурсивный процесс), монады, как абстракцию последовательных вычислений и~т.\,д.

В то время, как выразительная мощь и~последовательная модульность объектно-ориентированного подхода заключается в~абстракции данных, функциональная парадигма достигает этого же абстракцией процедур. Написание и~использование функций высшего порядка делает функциональные программы более надёжными, модульными и, при~правильном подходе, более прозрачными для человека. 
Однако, как и~везде, нужно уметь вовремя остановиться в~повышении уровня абстракции. Программисту необходимо помнить принцип: «Хуже обобщения одного примера может быть только обобщение вообще без~примеров»\footnote{Это один из~принципов, провозглашённых создателями оконной системы X~Windows, используемой в~UNIX-подобных системах и~в Mac OS X.}.

\section[2]{Аппликация}\index{аппликация}%
Одной из~самых важных функций высшего порядка является функция \sbi{apply}. Она передаёт список аргументов другой функции, являющейся её первым аргументом:

\begin{example}{Примеры применения функции \s{apply}.}
\REPL
  {(apply cons '(x y))}
  {(x . y)}

\REPL
  {(apply / '(2 3))}
  {2/3}
\end{example}

\begin{example}{Пример с~формальной функцией}
\REPLin{(define-formal f)}
\REPL
  {(apply f '(x y z))}
  {(f x y z)}
\end{example}

\begin{example}{Таким образом мы можем получить сумму элементов списка.}
\REPL
  {(apply + '(1 2 3 4))}
  {10}
\end{example}

Эту функцию нельзя определить с~помощью других средств языка \Scheme. Процедура \emph{аппликации}, которую она осуществляет, является базовой, наряду с~процедурой \emph{абстракции},\footnote{Здесь имеется ввиду не~абстракция процесса, а~абстракция, как одна из~фундаментальных операций в~исчислении функций. Подробнее см.\,Занятие \ref{Less:lambda-calculus}, стр.\pageref{abstraction}.} реализуемой с~помощью \s{define} и~\s{lambda}.

\section{Композиция функций}%
\index{композиция функций}\emph{Композицией} называется последовательное вычисление двух функций, так, чтобы результат одной подставлялся в~качестве аргумента другой функции. Математически это записывается так:$$(f \circ g)(x) = f(g(x))$$
Таким образом, композиция $f \circ g$ сама представляет собой функцию. Говорят, что пространство функций замкнуто относительно композиции. Это означает, что композиция функций всегда является функцией. Композиция является \emph{абстракцией комбинирования функций}: с~её помощью мы можем порождать новые функции не~используя явных связываний и~формальных аргументов.

На языке \Scheme композиция нескольких функций одной переменной записывается с~помощью функционала \si{compose} следующим образом:
\begin{center}
\s{((compose f g h) x) arrow (f (g (h x)))}
\end{center}

\begin{example}{%
Композиция этих трёх функций представляет собой функцию $$x\mapsto\sqrt{\sin(x^2)}$$}

\REPL
  {(compose sqrt sin sqr)} 
  {\\\#<procedure>}

\REPL
  {((compose sqrt sin sqr) .5)}
  {0.4973971846065506}
\end{example}

\begin{Assignment}
Завершите определение функции \s{*compose}, возвращающей композицию произвольного числа функций:
\begin{Specification}
; compose :: (X \arrow Y) \ddd (A \ddd \arrow B) \arrow (A \ddd \arrow Y)
(define compose
  (/. f --> f
      f g --> %\normalfont\itshape  композиция двух функций %
      f g h ___ --> %\normalfont\itshape  композиция двух и более функций %))%\smallskip%
(test
  ((compose sqr +) 1 2 3)            36
  ((compose list list sqr +) 1 2 3)  '((36))
  ((compose +) 1 2 3)                6)
\end{Specification}
В третьем правиле подстановки \s{h ___} обозначает список произвольного числа аргументов (см.~стр.~\pageref{variadic-rewrite}).
\end{Assignment}


\section[4]{Каррирование и~частичное применение~функции}%
Часто, при~обработке списков, бывает нужно применить к~его элементам функцию двух аргументов, при~этом зафиксировав один из~них. Пусть, например, нам нужно увеличить все элементы списка на~единицу, или сравнить их с~числом. Мы можем решить эти задачи таким образом:

\begin{SchemeCode}
(map (lambda (x) (+ 1 x)) '(1 2 3))
(map (lambda (x) (< x 2)) '(1 2 3))
\end{SchemeCode}

Из бинарных функций \s{+} и~\s{<} мы с~помощью \lmфункций создали унарные функции. Абстракцией этой операции для функций произвольного количества аргументов является \emph{каррирование}.
\index{каррирование}

Функцию от~нескольких аргументов $f(x, y, z)$ можно представить, как композицию нескольких функций от~одной переменной:$$f(x, y, z) = x \mapsto (y \mapsto (z \mapsto f (x, y, z)))$$

Такое представление и~называется \emph{каррированием функции} нескольких переменных. Каррированная функция $f$ своему первому аргументу $x$ ставит в~соответствие функцию от~$y$ и~$z$. Если мы подставим два аргумента $x$ и~$y$, то в~результате получим функцию только от $z$. Подстановка всех трёх аргументов даёт конечный результат. Уменьшение арности функции засчёт фиксирования некоторых её аргументов называется \emph{частичным применением}.

Таким образом, каррирование является преобразованием функции от~нескольких аргументов в~функцию, берущую свои аргументы по~одному. Оно весьма удобно в~функциональном программировании, поскольку при~создании языка требует описания механизма работы только с~функцией одного аргумента (при условии, что эта функция тоже может возвращать функции). Далее, этот механизм с~помощью каррирования расширяется на~случай функций произвольного количества аргументов.

\label{ML-notation}\index{нотация!бесскобочная}В очень многих функциональных языках программирования все функции каррированы и~это позволяет обходиться без~функциональных скобок при~их применении. Например, аппликацию функции трёх переменных $f(x, y, z)$ можно записать так: $f~x~y~z$, имея ввиду, что аргументы передаются функции справа налево. То есть, тернарная функция $f$, получив аргумент $x$ зафиксировала его и~превратилась в~бинарную функцию: $(f\ x)$. Далее она получает аргумент $y$ и~превращается в~унарную функцию $((f\ x)\ y)$ Когда эта функция получит свой аргумент, вычисление будет завершено. Скобки в~выражении $(((f\ x)\ y)\ z)$ можно убрать, если считать операцию аппликации \emph{право-ассоциативной}. Так и~поступают в~языках типа \Lang{ML}, \Lang{Haskell} и~т.\,п.

В языке \Scheme определение каррированной функции возможно двумя эквивалентными способами:
\begin{center}
\begin{tabular}{lcl}
\begin{SchemeCode}
(define f
  (lambda (x)
    (lambda (y)
      (lambda (z) body))))
\end{SchemeCode} & или &
\begin{SchemeCode}
(define (((f x) y) z)
  body)
\end{SchemeCode}
\end{tabular}
\vspace{-2\bigskipamount}
\end{center}
При этом используется такой важный механизм, как \index{замыкание}\emph{замыкание}, то есть способность функции запоминать окружение в~котором она была создана.

\begin{example}{Определим каррированную функцию сложения двух чисел.

Её частичное применение возвращает функцию одного аргумента, которая к~аргументу прибавляет 2.}
\begin{mREPLin}
> (define ((adder x) y)
    (+ x y))
\end{mREPLin}

\REPL
  {(adder 2)}
  {\\\#<procedure>}

\REPL
  {((adder 2) 6)}
  {8}
\end{example}


\begin{example}{Частично применённую функцию нескольких аргументов можно использовать, как любую другую функцию. Так мы можем объявить функцию \s{3+}, увеличивающую свой аргумент на~3.}
\REPLin
  {(define 3+ (adder 3))}

\REPL
  {(map 3+ '(1 2 3))}
  {(4 5 6)}
\end{example}

\begin{Assignment}

а) Напишите функционал \fun{curry}{f xs \ddd}, который возвращал бы функцию \lex{f}, каррированную с~аргументами \lex{xs}. 

\newcommand{\range}[2] {A${}_{#1}$\,\ddd\!A${}_{#2}$}

\begin{Specification}
; curry :: (\range{1}{n} \range{n+1}{m} \arrow B) \range{1}{n} \arrow (\range{n+1}{m} \arrow B)
(test
  (map (curry * 2) '(1 2 3))   '(2 4 6)  ;$(2\times1\ 2\times2\ 2\times3)$
  (map (curry - 2) '(1 2 3))  '(1 0 -1) ;$(2-1\ 2-2\ 2-3)$
  ((curry list 1 2) 3 4)     '(1 2 3 4))
\end{Specification}

б) Для некоммутативных операций не~всё равно какой аргумент отбрасывается при~каррировании. В~нашей реализации аргументы каррированной функции подставляются «справа». Напишите функционал \si{curryr}, каррирующий функцию, фиксируя «правый аргумент»: 

\begin{Specification}
; curryr :: (\range{1}{n} \range{n+1}{m} \arrow B) \range{n+1}{m} \arrow (\range{1}{n} \arrow B)
(test 
  ((curryr list 1 2) 3 4)      '(3 4 1 2)
  (map (curryr - 2) '(1 2 3))  '(-1 0 1)   ;$(1-2\ 2-2\ 3-2)$   
  (map (curryr < 2) '(1 2 3))  '(#t #f #f))  
\end{Specification}
\end{Assignment}

\section{Некоторые полезные функционалы}\label{operators}%
Приведём ещё несколько полезных функционалов, которые помогут нам упрощать и сокращать определения функций. 

\fun{negate}{pred?}~--- функционал возвращающий отрицание предиката \lex{pred?}.

\begin{example}{С помощью функционала \s{negate} определим предикат, возвращающий \s{\#t}, если аргумент не~равен нулю.}
\begin{ExampleCode}
 > (map (negate zero?) 
        '(2 -9 0))
\end{ExampleCode}
\REPLout
  {(#t #t #f)}
\end{example}

\fun{const}{C}~--- тождественная функция, возвращающая значение константы \lex{C} для любых аргументов.

\begin{example}{Тождественная функция \s{const}, принимая любое количество любых аргументов возвращает константу.}
\REPL
  {((const 5) 1 2)}
  {5}

\REPL
  {(map (const 'a) '(2 9 0))}
  {(a a a)}

\REPL
  {((const 5))}
  {5}
\end{example}

\fun{arg}{n}~--- тривиальная функция, возвращающая \lex{n}-ный переданный ей аргумент.

\begin{example}{Тривиальная функция \s{arg} принимая любое количество любых аргументов возвращает заданный аргумент.}
\REPL
  {((arg 2) 'x 'y 'z)}
  {y}
\end{example}

через функцию \s{arg} выражаются два часто встречающиеся оператора \si{I1} и \si{I2}:
\begin{SchemeCode}
  (define I1 (arg 1))
  (define I2 (arg 2))
\end{SchemeCode}

\fun{nest}{b u}~--- разновидность композиции для унарной функции \lex{u} и~бинарной \lex{b}, выполняющая следующее преобразование:
\begin{center}
\s{((nest b u) x y) arrow (b (u x) y)}
\end{center}

\begin{example}{%
Сначала первый аргумент передаётся унарной функции \s{sqr}, затем результат вместе со~вторым аргументом передаётся бинарной функции \s{cons}.} 
\REPL
  {((nest cons sqr) 2 3)}
  {(4 . 3)}
\end{example}

\fun{fif}{test? f g}~--- оператор выбора функции по~функции\=/предикату. Все функции\=/аргументы этого оператора получают одинаковые аргументы.

\begin{example}{Функция, округляющая число до~ближайшего чётного числа.}
\begin{ExampleCode}
 > (map (fif even? I1 add1))
        '(1 2 3 4 5))
\end{ExampleCode}
\REPLout{(2 2 4 4 6)}
\end{example}

\begin{Assignment}
а) Определите функционалы \s{negate}, \s{const}, \s{nest}, \s{arg} и~\s{fif}. Дайте спецификацию их типа.

б) Опертор композиции функций должен удовлетворять следующим свойствам:
\begin{itemize}
  \item ассоциативность: $(f \circ g) \circ h = f \circ (g \circ h)$,
  \item наличие нейтрального элемента: $f \circ id = id \circ f = f$.
\end{itemize}
Проверьте, удовлетворяют ли этим свойствам написанные вами варианты операторов \s{compose} и \s{nest}. Сравните их действие с системными реализациями: рассмотрите  композицию функций различной валентности.
\end{Assignment}

\section[2]{Бесточечная нотация}\index{нотация!бесточечная}\label{tacit}%
Часто, при определении функции нет необходимости описывать, как она действует на~свои формальные аргументы. Вместо этого можно дать определение её действию в~целом.

Например, давая определение предикату \si{atom?}, который проверяет, является ли объект элементарным или составным, мы можем написать прямое определение:

\begin{Definition}[emph=x]
; atom? :: A \arrow Bool
(define (atom? x) (not (pair? x)))
\end{Definition}
\noindent или определение, использующее функционал \s{negate}:
\begin{Definition}[emph=x]
; atom? :: A \arrow Bool
(define (atom? x) ((negate pair?) x))
\end{Definition}
\noindent при~этом мы видим, что формальный аргумент \lex{x} никакой информации этому определению не~добавляет и~его можно опустить:
\begin{Definition}
; atom? :: A \arrow Bool
(define atom? (negate pair?))
\end{Definition}
\noindent Это пример определения, записанного в~\emph{бесточечной нотации}.

\label{union}Приведём ещё один простой пример. Посмотрите на~определение функции, возвращающей объединение двух множеств, представленных списками:
\begin{Definition}[emph={s1,s2}]
; union :: [A] [A] \arrow [A]
(define (union s1 s2)
  (remove-duplicates (append s1 s2)))
\end{Definition}
\noindent Видно, что мы передаём аргументы сначала функции \s{append}, которая объединяет два списка-множества в~один, а~потом результат передаём функции \s{remove-duplicates}. Она, в~свою очередь, выделяет множество элементов этого списка, удаляя дубликаты. Поток данных можно схематически показать так:
\begin{center}
\s{s1, s2  $\longrightarrow$  append  $\longrightarrow$  remove-duplicates}
\end{center}

\noindent С~точки зрения функционального программирования, мы имеем композицию функций \s{append} и~\s{remove-duplicates}. Следовательно, мы можем дать следующее определение операции объединения:

\begin{Definition}
; union :: [A] \ddd \arrow [A]
(define union (compose remove-duplicates append))
\end{Definition}

Это именно определение функции, поскольку функционал \s{compose} возвращает функцию. Нам не~требуется указывать её формальные аргументы. Более того, нам даже не~нужно указывать их количества. Постольку поскольку функция \s{append} обрабатывает любое количество аргументов, наша функция \s{union} будет обладать таким же свойством!

\begin{example}{Функция \s{union} может работать с~любым количеством аргументов.

Попробуйте вызвать её с~одним аргументом или вовсе без~них.}
\REPL
  {(union '(1 2 3) '(2 3 4))}
  {(1 2 3 4)}

\REPL
  {(union '(a b c) '(1) '(b))}
  {(a b c 1)} 
\end{example}

Важную роль в бесточечном определении функций играет каррирование. Например, имея функцию \s{accumulate} (стр. \pageref{accumulate}), мы можем определить функцию \s{sumf}, вычисляющую $\sum_{i=a}^b f(i)$,  следующим образом:
\begin{SchemeCode}[emph={f,a,b}]
  (define (sumf f a b) (accumulate + 0 f a b))
\end{SchemeCode}
или с помощью частичного применения:
\begin{SchemeCode}
  (define sumf (accumulate + 0))
\end{SchemeCode}
При этом имеется в виду, что свободные аргументы \lex{f a b} становятся аргументами функции \s{sumf}.

Так можно определить функцию, вычисляющую $\sum_{i=a}^b i^2$. Зафиксировав первый аргумент функции \s{sumf} мы оставляем пределы суммирования свободными.
\begin{SchemeCode}
   > (define sumsq (sumf sqr))
\end{SchemeCode}
\REPL
  {(sumsq 1 3)}
  {14} 

В диалекте \FLP для определений функций с использованием каррирования служит форма \sfi{define/c}:\label{define-c} 
\begin{SchemeCode}
(define/c (f x y ...) body).
\end{SchemeCode}
Выражение \s{(f x y ...)} представляет собой частичное применение опрделяемой функции \s{f}. При этом, если выражение \s{body} возвращает функцию, то её формальные аргументы становятся свободными аргументами функции \s{f}.

Вот, как с помощью формы \s{define/c}, можно определить функцию \s{map}:
\begin{SchemeCode}[emph={f,h,t}]
(define/c (map f)
  (/. '() --> '()
      (cons h t) --> (cons (f h) (map f t))))
\end{SchemeCode}
В заголовке этого определения мы зафиксировали первый аргумент функции \s{map}, оставив свободными аргументы функции, заданной подстановкой. Так как подстановка является унарной, то в результате, мы получаем бинарную функцию:
\REPL
  {(map sqr '(1 2 3))}
  {(1 4 9)} 

Бесточечная нотация делает функциональные программы более декларативными. Вместо описания функции, как последовательности действий над~аргументами она описывает, чем является эта функция по~отношению к~другим функциям.

Бесточечный стиль характерен для функциональных языков и~широко используется в~языках семейства \Lang{ML}. Однако нужно уметь «вовремя остановиться», используя его. Основная цель такой записи~--- повысить понятность кода и~его надёжность. Однако, используя бесточечный стиль, очень легко превратить программу в~бессмысленный, на~первый взгляд, набор функций и~комбинаторов. Рекомендуется применять бесточечную запись только тогда, когда она чётко и~ясно отражает структуру определяемой функции, приближая определение к~словесному описанию.

\section[4]{Функции высшего~порядка за~пределами~\Scheme}%
Функции высшего порядка можно создавать и~использовать во~всех языках, которые позволяют передавать качестве аргументов функций другие функции или указатели на~них.
Во всех функциональных языках функции~--- объекты первого класса и~создание функций высшего порядка для них естественно.

В языке \Lang{С++} можно создавать такие функции с~помощью указателей на~функции. В~языке \Lang{Pascal} (\Lang{Delphi}) и~прочих объектно-ориентированных языках можно передавать функцию, как метод объекта.

\index{замыкание}Важным инструментом для создания функций высшего порядка является механизм замыкания, который позволил нам описать каррирование функций. Замыкание присутствует во~многих языках: \Lang{С++} использует для этого функторы или блоки; \Lang{Delphi}, \Lang{Perl}, \Lang{Python} и~\Lang{JavaScript}~--- анонимные функции, \Lang{Java}~--- использует анонимные классы внутри методов.

\begin{Queeze}

\item Какая функция называется функцией высшего порядка? Приведите примеры.

 \item Какую роль играют функции высшего порядка и~функционалы в~программировании?

 \item Абстракцией какого процесса является оператор \s{fif}?

 \item Какие функции являются абстракциями комбинирования функций, аппликации функций, частичного применения, рекурсивного обхода древообразной структуры?

 \item Что такое бесточечная нотация?

\end{Queeze}
