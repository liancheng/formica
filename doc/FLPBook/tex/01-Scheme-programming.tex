%!TEX root = main.tex
% revision is done
\Lesson{Программирование на~\Scheme}

\label{Les:Scheme-programming}

\section{Синтаксис языка \Scheme}\label{Sec:expressions}%
%
Синтаксис \Lang{Scheme} и его диалектов столь прост и, вместе с~тем, последователен, что часто можно услышать утверждение, что <<в~\Lang{Scheme} нет синтаксиса>>. Конечно же, это преувеличение, но оно отражает главную особенность языков, ведущих свою родословную от~языка \Lisp: всё с~чем имеют дело и~программист и~транслятор~--- это универсальная синтаксическая структура, называемая \index{S-выражение}\emph{S-выражением} или просто \emph{выражением}.{\tolerance=500\par}

Приведём неполное, но практичное описание выражения, которое может быть программой \Scheme\footnote{На Занятии \ref{Less:lists} мы дадим полное формальное описание S-выражения.}:

\begin{itemize}[--]
 \item Любое выражение может быть либо \emph{атомом}, либо \emph{списком}. 
 \item \index{атом}Атомы могут быть \emph{константами} или \emph{символами}.\footnote{Тут возможна некоторая путаница в терминологии, от того что в русском языке слова «символ» и «знак» часто означают одно и то же: букву или специальный знак алфавита. В английском языке для знаков используется только слово «character», а слово «symbol» имеет более общее значение. В традиции языка \Lisp \emph{символ}~--- это последовательность одного или более \emph{знаков}, играющая роль идентификатора, имени функции или синтаксической конструкции.} 
\begin{itemize}[--]
 \item Константами являются \emph{числа}, \emph{строки} или \emph{булевы} \emph{константы}.
 \item\label{symbol}\index{символ}Символом является любая последовательность знаков латинского, русского или какого-либо ещё алфавитов, а~так же знаков препинания, не~включающая в~себя пробела и~служебные знаки: \s{" , ' ` ( ) [ ] #}. 
\end{itemize}
 \item Списки имеют следующий вид \s{(expr ...)}, где \s{expr} --- произвольные выражения. Элементы списка разделяются пробелами.
\end{itemize}

Всё, никаких других синтаксических правил или конструкций для написания программ нам не~понадобится. Если нам и~будут встречаться исключения, то они являются <<синтаксическим сахаром>>, призванным облегчить читаемость программы и~в любом случае, можно обойтись без~них.

Приведём несколько примеров:

\smallskip
\begin{tabular}{>{\comment\raggedright}p{0.3\textwidth}p{0.7\textwidth}}
  Примеры констант: & \parbox{0.7\textwidth}{\s[basicstyle=\constantstyle]{1,  -2.3, 1/3,  1.3e5, \#t, \#f, "abc"}}\\
  Примеры символов: & \parbox{0.7\textwidth}{\s{x,  abc,  =, 1+x,  a->b, zero?}}\\
  Примеры выражений: & \parbox[t]{0.7\textwidth}{\s{1,  x,  (a b),  (+ 1 2),}\\ \s{(f (g a) (g b)),  ((("abc")))}} 
\end{tabular}
\smallskip

Обратите внимание на~то, что, в~отличие от~большинства языков программирования, символы, играющие роль идентификаторов, могут начинаться с~цифр и~включать в~себя разнообразные знаки, не~относящиеся к~алфавиту.

\section{Голова и хвост выражения}%
%
С точки зрения интерпретатора, выра\-жение-список имеет две функционально различные части: \emph{голову}\index{голова выражения} (head) и \emph{хвост}\index{хвост выражения} (tail). Головой является первый элемент выражения, хвостом~--- последовательность остальных элементов. Например, у~выражения \s{(a b c)} головой является символ \s{a}, а~хвостом~--- последовательность символов \s{b}~и~\s{c}.{\tolerance=500\par}

Голова играет роль имени функции, а~хвост~--- последовательности её аргументов. Таким образом, имеется следующее соответствие между математическим обозначением функции и~её записью в~виде выражения \Scheme:
\begin{equation*}
f (x, y,...) \to  \text{\s{(f x y ...)}}
\end{equation*}
\index{нотация!префиксная}Такая форма записи арифметических выражений называется \emph{префиксной скобочной нотацией}.

\section[4]{Простейшие арифметические действия}%
%
Префиксная форма записи последовательно используется для любых выражений \Scheme. Запись арифметических выражений не является исключением и подчиняется общему синтаксическому правилу:
$$
\text{\s{(operator expr1 expr2 ...)}}.
$$
И,~хотя для арифметики такая запись выглядит громоздкой, она не~лишена смысла. Она становится более понятной, если читать её, как выражение <<человеческого>> языка:

\begin{example}{%
<<сумма единицы и двойки>>,

<<разность двойки и тройки>>,

<<произведение трёх и суммы двух, четырёх и четырнадцати>>.}
\begin{ExampleCode}
(+ 1 2)
(- 2 3)
(* 3 (+ 2 4 14))
\end{ExampleCode}
\end{example}

Функции \s{+}, \s{*}, \s{-} и~\s{/} могут принимать любое количество аргументов. При~этом для функций \s{-} и~\s{/} все аргументы, начиная со второго являются, соответственно, вычитаемыми и~делителями. Арифметические выражения со многими аргументами вычисляются следующим образом:

\begin{example}{%
$1+2+3+4$

$1-2-3-4$

$1\times2\times3\times4$

$1/2/3/4 = \frac{1}{2\cdot3\cdot4}$}
\begin{ExampleCode}
(+ 1 2 3 4)
(- 1 2 3 4)
(* 1 2 3 4)
(/ 1 2 3 4)
\end{ExampleCode}
\end{example}


\section{Типы числовых констант}\index{константы!числовые}%
В языке \Scheme определены два основных типа числовых констант: \emph{точные} (exact) и~\emph{неточные} (inexact). Каждая из них делится на~иерархические группы. Самым общим является тип \emph{комплексных} чисел. Для точных чисел он включает в~себя \emph{рациональные} числа, а~они, в~свою очередь, \emph{целые}. Неточные комплексные числа включают в~себя \emph{действительные числа с~плавающей точкой}.

\begin{itemize}[--]
  \item точные
  \begin{description}\small
    \item[\parbox{2.8cm}{целые}] \s[basicstyle=\constantstyle]{1, -2, 34, 32567}
    \item[\parbox{2.8cm}{рациональные}] \s[basicstyle=\constantstyle]{1/2, -3/4, 48/31, 3/10}
    \item[\parbox{2.8cm}{комплексные}] \s[basicstyle=\constantstyle]{1+2i, 0-5i, 1/2-3/5i}
  \end{description}
  \item неточные
  \begin{description}\small
    \item[\parbox{2.8cm}{действительные}] \s[basicstyle=\constantstyle]{1.2, 1e-2, -2.34e34, 0.3}
    \item[\parbox{2.8cm}{комплексные}] \s[basicstyle=\constantstyle]{1+1.0i, -3.14+2.3i, 0.+1.i}
  \end{description}
\end{itemize}

Количество значащих цифр в~точных числах ограничивается только памятью машины, то есть, формально его можно считать неограниченным:
\REPL
  {(expt 2 200)}
  {1427247692705959881058285969449495136382746624}
\REPL
  {(expt 3+1/2i 23)}
  {-428527467338522001/4194304-660817678420542493/8388608i}
Здесь функция \bfun{expt}{x y} вычисляет $x^y$.

\bfnindex{sqrt}
\begin{example}{%
Иррациональные и~трансцендентные функции почти всегда возвращают результаты в~виде неточных чисел. Исключения составляют, например, корни из~целых квадратов.}
\REPL
  {(sqrt 2)}
  {1.4142135623730951}
\REPL
  {(exp 3)}
  {20.085536923187668}
\REPL
  {(sqrt -4)}
  {0+2i}
\end{example}

\begin{Assignment}
а) Вычислите следующие выражения в~окне интерпретатора \DrRacket:
$$
\frac{3- 2\cdot(3/2-5^2)}{9\cdot 8\cdot 7\cdot 6\cdot 5},\qquad
2^{3^4},\qquad
\frac{1}{1+\frac{1}{1+1/2}},\qquad
\frac{1}{\sqrt{\pi}}e^{-1,5^2}.
$$

б) Выясните с помощью интерпретатора, как вычисляются такие выражения: \s{+}, \s{(+ 1)}, \s{(+)}, \s{(- 2)}, \s{(-)}, \s{(/ 3)}, \s{(/)}.
\end{Assignment}



\bsfindex{define}
\section{Определения с~помощью define}%
\label{define}Программирование высокого уровня начинается с~возможности давать данным или действиям понятные для человека имена. В~языках программирования базовым инструментом для этого служат присваивания и~определения функций и~процедур. В~языке \Scheme для этого
используются определения, которые \emph{связывают} символы с~их значениями. Это делается с~помощью специальной формы \s{define}.

\begin{example}{%
Дадим определение символу \s{a}. Теперь этот символ связан со~значением 2.}
\REPLin
  {(define a 2)}
\REPL
  {a}
  {2}
\end{example}


\begin{example}{%
Мы можем использовать это определение и~в арифметических действиях, и~в других определениях.}
\REPLin
  {(define b (+ a a))}
\REPL
  {b}
  {4}
\end{example}

Вспомним, как записывается применение функции: \s{(f x y ...)}. Задавая определение для функции, мы синтаксически определяем, что интерпретатор должен сделать, встретив подобную конструкцию.

\begin{example}{%
Таким образом определяется функция \s{sqr}\fnindex{sqr}, возводящая вещественное число в~квадрат.}
\begin{ExampleCode}
> (define (sqr a)
    (* a a))
\end{ExampleCode}
\REPL
  {(sqr 4)}
  {16}
\end{example}

\begin{example}{%
Классический пример: определим вычисление площади круга. Здесь символ \s{pi} обозначает число $\pi$.}
\begin{ExampleCode}
> (define (area r)
    (* pi (sqr r)))
\end{ExampleCode}
\REPL
  {(area 4)}
  {50.26548245743669}
\end{example}

\section{Тип функций и~их аргументов}%
\Scheme~--- язык с~\index{динамическая типизация}\emph{динамической типизацией}. Это означает, что типы выражений выводятся в~процессе выполнения программы и~определять их явно, как в~языке \Lang{C} или \Lang{Haskell}, не~нужно. Однако, для лучшего понимания того, что должна делать та или иная функция, полезно представить себе типы её аргументов и~тип возвращаемого результата. Мы будем делать это в~строке-комментарии перед определением функции. Комментарий в \Scheme начинается со~знака <<точка с~запятой>>. Например:

\begin{Definition}
; sqr :: Num \arrow Num
(define (sqr a)
  (* a a))
\end{Definition}

\index{тип!функции}Это описание типа говорит нам, что функция \s{sqr} является отображением из~множества чисел во~множество чисел. А~с точки зрения программиста, это значит, что она принимает один числовой аргумент и~возвращает число. Формальное описание типа функции называется её \index{сигнатура функции}\emph{сигнатурой}.

Договоримся, что названия типов будут начинаться с~заглавной буквы. Мы будем использовать следующие обозначения для простых типов:

\vspace{-\bigskipamount}
\begin{type}
   \item A, B, С --- {\TextComment произвольный тип}
   \item Bool --- {\TextCommentлогическая константа}
   \item Num --- {\TextCommentчисло}
   \item Int --- {\TextCommentцелое число}
   \item Str --- {\TextCommentстрока}
   \item A \arrow B --- {\TextCommentфункция одного аргумента}
   \item A B \arrow C --- {\TextCommentфункция двух аргументов}
   \item A \ddd\ \arrow B --- {\TextCommentфункция произвольного числа аргументов}
\end{type}

По мере введения составных типов данных: списков или потоков~--- мы будем давать им формальные определения. В~качестве примера, приведём определение типа, соответствующее выражению языка \Scheme, которое мы описали на~стр.~\pageref{Sec:expressions}\footnote{Здесь мы не~даём формального определения того, что такое число или символ, поскольку описываем не~синтаксис языка, а~формальный тип для структуры данных.}:

\vspace{-\medskipamount}
\begin{type}
\item Expr ::= Atom | (Expr \ddd)
\item Atom ::= Num | Str | Bool | Sym
\end{type}

Хотя в~\Scheme указывать тип функции не~нужно, а~в \Lang{Haskell}~--- не~обязательно, типы в~функциональных языках играют очень важную роль. Приведём слова математика Хаскелла Карри, одного из~основоположников теории функций: «... доказательством является программа, формулой, которую нужно доказать~--- тип программы». Мощная система абстрактных, алгебраических, полимофных и~рекурсивных типов вместе в~механизмом вывода типов, делают функциональную парадигму не~уступающей, а~во многом и~превосходящей по~выразительности и~уровню абстракции объектно-ориентированный подход.

\begin{Assignment}
Напишите определения для функций, вычисляющих среднее арифметическое и~среднее геометрическое двух чисел:

% \index{mean@Scheme@прочие функции}
\begin{Specification}
  ; mean :: Num Num \arrow Num
  (test 
    (mean 1 3)     ==> 2
    (mean 1+i 2-i) ==> 3/2)%\medskip%
  ; gmean :: Num Num \arrow Num
  (test 
    (gmean 2 3)     ==> (sqrt (* 2 3))
    (gmean 1+i 1-i) ==> (sqrt 2))
\end{Specification}

\tip{Указание: Прежде чем начинать реализацию функции, скопируйте в~окно определений спецификацию функций. Своё определение пишите между описанием типа и~тестовыми примерами:}%\vspace{-\bigskipamount}
\begin{Specification}
  ; mean :: Num Num \arrow Num
  (define (mean x y)  ...)
  (test 
    (mean 1 3)     ==> 2
    (mean 1+i 2-i) ==> 3/2)
\end{Specification}%\vspace{-\medskipamount}

\tip{Форма \sflpi{test} служит для тестирования написанных вами функций. Она принимает последовательность выражений и сравнивает первое со вторым, третье с четвёртым и т.д. Если при выполнении тестов не выводится никаких сообщений об ошибках, значит все сравнения прошли успешно и определённая вами функция соответствует спецификации.}
\end{Assignment}

\section[2]{Условные выражения}\bsfindex{if}%
Для программирования более сложных функций, необходимо иметь возможность производить проверки и выполнять различные действия, в зависимости от результата проверки. 
Простейшее управление потоком вычислений в~\Scheme выполняет специальная форма~\s{if}:
\begin{SchemeCode}
(if test? expr1 expr2)
\end{SchemeCode}

\noindent Её, с~некоторыми оговорками, можно воспринимать, как функцию, возвращающую второй аргумент (\s{expr1}) в~случае выполнения условия \s{test?} и~третий (\s{expr2})~--- в~противном случае.

\index{константы!булевы}Условия, используемые в~форме \s{if}, должны возвращать величины булевского типа. В~\Scheme используются следующие символы:
\begin{itemize}[--]
 \item для обозначения истинного значения --- \s{#t},

 \item для обозначения ложного значения --- \s{#f}.
\end{itemize}

Кроме того, в~\Scheme любое значение, кроме ложного, считается истинным:

\begin{example}{%
В первом случае число 1 сработало, как истинное значение: форма \s{if} вернула второй аргумент. <<По-настоящему>> ложной является только константа \s{\#f}.}
\REPL
  {(if 1 2 3)}
  {2}
\REPL
  {(if \#f 2 3)}
  {3}
\end{example}


Роль операторов сравнения для числовых данных выполняют функции \s{=}, \s{<}, \s{>}, \s{<=} и~\s{>=}.

\begin{example}{%
Примеры использования функций сравнения.}
\REPL
  {(< 2 3)}
  {\#t}
\REPL
  {(= 2 2.0)}
  {\#t}
\end{example}

\vspace{-\medskipamount}
\begin{example}{%
Операторы сравнения могут принимать более двух аргументов, в~таком случае выполняется проверка на~одновременное выполнение условия для всех последовательных пар аргументов.}
\REPL
  {(> 5 4 3 2 1)}
  {\#t}
\REPL
  {(< 2 3 4 3)}
  {\#f}
\end{example}

\index{предикат}Условия можно описывать явно, например, с~помощью операторов сравнения, или оформлять их в~виде именованных функций-предикатов. По~договорённости, имена предикатов заканчиваются знаком <<\s{?}>>. Например, \s{integer?}, \s{positive?}, \s{zero?}, \s{even?}, \s{odd?} и~т.\,п.

Использование именованных предикатов вместо явных условий делает программу более легко читаемой и~считается хорошим стилем.

\begin{example}{Так можно определить модуль от~действительного числа. Здесь мы использовали предикат \fun{negative?}{x}, возвращающий значение \s{\#t} для отрицательных значений \lex{x}.}
\begin{ExampleCode}[emph=x]
> (define (abs x)
    (if (negative? x) 
        (- x) x))
\end{ExampleCode}

\REPL
  {(abs 4)}
  {4}

\REPL
  {(abs -4)}
  {4}
\end{example}

Если требуется выполнение нескольких условий, их можно комбинировать с~помощью логических операций \si{and}, \si{or} и~\si{not}.


\begin{example}{Определим предикат принадлежности числа к~множеству натуральных чисел.\fnindex{natural?}}
\begin{ExampleCode}
(define (natural? x)
  (and (integer? x)
       (positive? x)))
\end{ExampleCode}
\end{example}

При необходимости создания более двух ветвей выполнения, вместо вложенных форм \s{if} используется форма \sfi{cond}:
\begin{SchemeCode}[]
(cond
  [test1 expr1]
  [test2 expr2]
  ...
  [else $else$-$expr$])
\end{SchemeCode}

Вас не~должны смущать квадратные скобки, они играют ту же самую роль, что и~круглые и~всегда можно обойтись без~них. Более того, в~программе \DrRacket символы квадратных скобок почти всегда автоматически заменяются на~круглые, за~исключением некоторых специальных форм.

Выражение \s{else-expr}, указанное после ключевого слова \s{else} выполняется в~том случае, когда ни~одно из~условий \s{test1}, \s{test2}, ... не~вернуло истинного значения. Ветви \s{else} может и~не быть.

\begin{example}{Определение функции $sign(x)$, возвращающей знак числа.}
\begin{ExampleCode}
(define (sign x)
  (cond
    [(negative? x) -1]
    [(zero? x) 0]
    [else 1]))
\end{ExampleCode}
\end{example}

Логические операции \s{and} и~\s{or} так же можно использовать, в качестве операторов ветвления, поскольку они производят вычисления только тех аргументов, которые могут изменить результат:

\begin{example}{%
В этих примерах второй аргумент не~вычисляется. Поскольку для любого $x$ верно, что

$true\ \text{или}\ x = true$

$false\ \text{и}\ x = false$}
\REPL
  {(or (< 1 2) (/ 1 0))}
  {\#t}
\REPL
  {(and (< 2 1) (/ 1 0))}
  {\#f}
\end{example}

\begin{example}{Так можно определить предикат с~охраной, возвращающий \s{\#t} только для положительных действительных чисел и~\s{\#f} для всех прочих объектов. Использование предиката \s{positive?} для двух последних случаев вызвало бы сообщение об~ошибке.}
\begin{ExampleCode}
> (define (positive-num? x)
    (and (real? x)
         (positive? x)))
\end{ExampleCode}
\REPL
  {(positive-num? 6)}
  {\#t}
\REPL
  {(positive-num? 2-i)}
  {\#f}
\REPL
  {(positive-num? "abs")}
  {\#f}
\end{example}

\section[2]{Программы \Scheme}%
Введённые в~окне интерпретатора определения, хоть и~работают, программой не~являются. При~выходе из~\Lang{DrRacket} все они будут потеряны. Естественно сохранить их в~файл, затем, чтобы использовать в~дальнейшем.

Записанные в~верхней половине окна \Lang{DrRacket} и~сохранённые определения превращаются в~полноценную программу, её можно откомпилировать, выполнить, сохранить и~загрузить.

Заголовок простейшей программы должен состоять из~указания языка, на~котором она написана. Для использования \Scheme, следует указать заголовок \s{#lang formica}:

\begin{example}{Напишем небольшую программу.

В ней мы определяем две функции \s{area} и \s{perimeter}.}
\begin{ExampleCode}[emph={r}]
#lang formica

; area :: Num \arrow Num
(define (area r)
  (* pi (sqr r)))

; perimeter :: Num \arrow Num
(define (perimeter r)
  (* 2 pi r))
\end{ExampleCode}
\end{example}

Сохраним эту программу под~именем, скажем, \s{circle.rkt}. Нажатие клавиш \MenuItem{F5} или \MenuItem{Ctrl+T} заставит \Lang{DrRacket} выполнить её. После этого, мы можем воспользоваться определёнными в~программе функциями в~окне интерпретатора.

Нажатие клавиши \MenuItem{F6} позволит просмотреть синтаксическую структуру программы. В~этом режиме, наведение указателя мыши на~символ покажет, где дано его определение или где  он используется.


\section[4]{Компиляция и~создание приложений}\label{compilation}%
Для освоения принципов функционального программирования и~характерных для него алгоритмических приёмов и структур данных, нам будет достаточно общения с~интерпретатором. Но \Scheme~--- это язык для решения прикладных задач и, если перед нами встаёт задача создания приложения (файла, исполняемого операционной системой), программу надо будет откомпилировать. При~этом необходимо позаботиться о~вводе данных и~о выводе результата.

Приведём пример простейшей программы с~вводом-выводом:
\begin{Definition}[emph={r}]
#lang flp

; определения

; area :: Num \arrow Num
(define (area r)
  (* pi (sqr r)))

; perimeter :: Num \arrow Num
(define (perimeter r)
  (* 2 pi r))


; input
(display "Enter the radius:")
(define r (read))

; output
(display "Area: ")
(display (area r))
(newline)
(display "Perimiter: ")
(display (perimeter r))
\end{Definition}


Здесь мы использовали следующие функции: \bfun{display}{text}~--- выводит сообщение с~текстом \lex{text}; \bfun{read}{}~--- функция без аргументов, которая считывает выражение (последовательность символов до~пробела, символа перевода строки или табуляции) с устройства стандартного ввода; \bfun{newline}{}~--- выводит символ перевода строки.

Все эти функции по~умолчанию работают со~стандартными портами ввода и~вывода: \s{stdin} и~\s{stdout}. Однако, им можно указать порт, который может быть, например, файлом или строкой. Подробнее об~этом можно узнать из~документации \Lang{Racket}.

Далее, в~меню программы \Lang{DrRacket} выбираем \MenuItem{Racket | Создать исполняемый файл...} В~появляющемся диалоговом окне мы можем указать имя и~расположение создаваемого исполняемого файла, его тип и~используемый компилятор (\s{racket} или \s{gracket}\Lang{\footnote{\s{racket}~--- это компилятор \Racket, создающий эффективный код. \s{gracket}~--- это <<отладочный>> компилятор, который сообщает об~ошибках в~окне исполняемого приложения. Для отладки лучше использовать \s{gracket}, для создания конечного приложения~--- \s{racket}.}}).

Типы создаваемых файлов бывают следующими:

\begin{itemize}[--]
 \item \MenuItem{Запуск в~оболочке}~--- создаётся скомпилированный файл, исполняемый в~оболочке \Lang{DrRacket}. Этот тип бывает нужен для отладки программ.

 \item \MenuItem{Автономный}~--- создаётся компактный исполняемый файл, использующий динамические библиотеки \Lang{DrRacket}.

 \item \MenuItem{Дистрибутив}~--- создаётся автономный исполняемый файл, включающий в~себя все необходимые для его работы динамические библиотеки.
\end{itemize}

После нажатия кнопки \MenuItem{Создать}, в~указанной директории появится исполняемый файл с~расширением \s{exe} для ОС Windows или без~расширения для Linux.

Мы больше не~будем заострять внимание на~компиляции и~инструментах ввода-вывода. В~языке \Scheme они реализованы вполне стандартным образом, как и~в большинстве прочих языков: в~виде работы с~портами и~потоками ввода-вывода. Есть в~этом языке и~весьма полный инструментарий для создания оконных приложений. Заинтересованный читатель всегда может обратиться к~руководству по~языку, включённому в~дистрибутив программы \Lang{DrRacket}.

\begin{Assignment}
а) Используя форму \s{if} или логические операции, напишите предикат \fun{divisible?}{x y}, определяющий делятся ли нацело вещественные числа \lex{x} и \lex{y}. 

\begin{Specification}
;divisible? :: Num Num \arrow Bool
(test
  (divisible? 4 2)
  (not (divisible? 4 3))
  (divisible? 7 3.5)
  (divisible? 7.5 -2.5)
  (divisible? 2 1)
  (not (divisible? 2.5 1))
  (divisible? 1 0))
\end{Specification}

б) Определите функцию 
\begin{equation*}
\mathrm{sinc}(x) = \left\{
\begin{array}{lll}
  \frac{\sin(x)}{x} &\text{если}& x \neq 0,\\
  1 &\text{если}& x = 0,\\
  0 &\text{если}& x~\text{кратно}~\pi.
\end{array}\right. 
\end{equation*}
 
\fnindex{sinc}
\begin{Specification}
; sinc :: Num \arrow Num
(test
  (sinc 2)        ==> (/ (sin 2) 2)
  (sinc pi)       ==> 0
  (sinc (* 6 pi)) ==> 0
  (sinc 0)        ==> 1)
\end{Specification}
\end{Assignment}

\newpage
\begin{Queeze}
 \item Какие синтаксические конструкции есть в~языке \Scheme?

 \item Как можно с~помощью \Scheme вычислять арифметические выражения?

 \item Как в \Scheme запоминать вычисленные значения для дальнейшего использования?

 \item Как создавать свои функции в \Scheme?

 \item Какие есть конструкции выбора в \Scheme?
\end{Queeze}
