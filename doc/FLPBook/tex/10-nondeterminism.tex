\Lesson{Недетерминистическое программирование}

\section[2]{Основные понятия}\index{вычисления!детерминистические}%
Традиционный детерминистический подход к программированию подразумевает, что всякая величина (переменная, значение функции и т.п.) в каждый момент времени выполнения программы может иметь единственное значение. Если же возникает необходимость перебрать несколько вариантов значений, организуется явный цикл.
Однако, при формулировке и решении ряда задач полезно мыслить иначе. Можно <<разрешить>> переменным иметь множество значений <<одновременно>>, при этом функции тоже должны иметь возможность возвращать множество результатов. Мы уже пользовались таким подходом, когда оперировали списками и множествами, как единым целым, используя вместо циклов операторы отображения, фильтрации или свёртки. 

Но сейчас мы пойдём дальше, и сделаем весь поток выполнения программы неявным. Программа будет содержать только лишь информацию о \emph{возможных} значениях входящих в неё величин, соотношения между этими величинами, а так же ограничения, определяющие цель --- решение задачи. При этом, на этапе написания программы неизвестно, какие именно значения из множества возможных, приведут к решению задачи. Такой подход называется \emph{недетерминистическим}.\index{вычисления!недетерминистические}

Для оперирования недетерминистическими величинами введём абстрактный полиморфный тип \Type{Amb}, с конструктором \s{amb}\index{тип!абстрактный!Amb} (от~английского \emph{ambivalent}):\smallskip
\begin{type}
  Amb(A) ::= \s{(amb)} | \s{(amb} A ...\s{)}
\end{type}\smallskip
Таким образом, выражение
\begin{SchemeCode}
  (define x (amb 1 2 3))
\end{SchemeCode}
будем воспринимать так: величина \s{x} может быть равна $1$, $2$ или~$3$.~ А~выражение
\begin{SchemeCode}
  (define y (amb 42))
\end{SchemeCode}
означает, что переменная \s{y} принимает одно единственное значение~$42$, что соответствует <<обыкновенной>> детерминистической величине.

Особый смысл имеет выражение \s{(amb)}. Оно означает как отсутствие вариантов, так и <<невозможное>> значение, логическое противоречие или неудачу в процессе поиска решения. Решение недетерминистической задачи заключается в поиске всех вариантов, не приводящих к противоречию.

Недетерминистические функции, в отличие от обыкновенных, возвращают не единственное значение, а множество возможных значений.
Например, если $x^2 = y$, то $x = \pm\sqrt{y}$. Таким образом, корень квадратный можно представить как недетерминистическую функцию, возвращающую положительное или отрицательное значение:

\begin{SchemeCode}
  ; n-sqrt :: Real \arrow Amb(Real)
  (define (n-sqrt x)
    (if (and (real? x) (positive? x))
        (let ([y (sqrt x)]) 
          (amb (- y) y))
        (amb)))
\end{SchemeCode}
Кроме того, в этом определении с помощью \s{(amb)} отражена невозможность вычисления  квадратного корня для аргумента, не являющегося вещественным положительным числом.

\section[4]{Реализация недетерминистических~вычислений}%
Существует несколько возможных реализаций недетерминистических вычислений. Мы~рассмотрим чисто функциональную реализацию, которая не только позволит нам построить работоспособную систему логического программирования, основанную на~методе хронологического поиска с~возвратом, но~и~приведёт нас к~важным понятиям монады и~продолжений.

В нашей функциональной реализации множество возможных значений можно представить в виде простого списка.
\begin{Definition}[emph={x,f}]
  ; amb :: A ... \arrow Amb(A)
  (define amb list)
\end{Definition}
Несмотря на тождественность функций \s{amb} и \s{list}, мы будем продолжать использовать \s{amb} там, где это необходимо для выражения неопределённости. Например выражение \s{(amb '(1 2) '(2 3))} означает два варианта значения в виде списков, в отличие от \s{(list '(1 2)} \s{'(2 3))}, означающего списочную структуру.

Рассмотрим теперь, каким образом мы сможем передавать функциям аргументы в рамках недетерминистических вычислений. Пусть, например, $x$ может быть равен $1$, $4$ или $9$, чему может быть равен квадратный корень из $x$? Ответ в этом случае такой: $1, -1, 2, -2, 3$ или $-3$. То есть, решением будет объединение всех возможных значений функции для всех возможных значений аргументов.

Обозначим функцию, объединяющую возможные варианты символом \s{amb-plus}. Постольку поскольку варианты представляются списками, годится такое определение:
\begin{Definition}[emph={x,f}]
  ; amb-plus :: Amb(A) Amb(A) \arrow Amb(A)
  (define amb-plus append)
\end{Definition}

Введём функцию \fun{amb-bind}{x f}, обобщающую понятие аппликации для недетерминистических функций.
\begin{Definition}[emph={x,f}]
  ; amb-bind :: Amb(A) (A \arrow Amb(B)) \arrow Amb(B)
  (define (amb-bind x f)
    (foldr (nest amb-plus f) (amb) x))
\end{Definition}
Эта функция сходна с~отображением \s{map} (см.~стр.~\pageref{fold:map}), отличаясь от~неё использованием вместо конструктора \s{cons} функции \s{amb-plus} и~вместо пустого списка --- выражения \s{(amb)}.

Теперь мы можем связывать недетерминистические величины и~функции:
\REPL{(amb-bind (amb 1 16) n-sqrt)}
     {(-1 1 -4 4)}
Попробуем применить недетерминистическую функцию \s{n-sqrt} повторно:
\REPL{(amb-bind (amb-bind (amb 1 16) n-sqrt) n-sqrt)}
     {(-1 1 -2 2)}
Обратите внимание на то, что наличие отрицательных чисел среди вариантов аргумента функции \s{n-sqrt} не~привело к~ошибке, поскольку согласно нашему определению, для таких аргументов решения просто не~существует.

\section{<<Синтаксический сахар>>}%
Функция \s{n-sqrt} была специально разработана так, чтобы возвращать варианты ответов. Однако, существует способ превратить любую уже определённую функцию в недетерминистическую. Так, например, мы можем вычислить квадрат недетерминистической величины:
\begin{SchemeCode}[emph={x}]
   > (amb-bind (amb 1 2 3) (lambda (x) (amb (sqr x))))
\end{SchemeCode}\vspace{-\medskipamount}
\REPLout{(1 4 9)}
А так --- возможные значения суммы двух недетерминистических переменных \s{(amb 10 20)} и \s{(amb 3 4 5)}:
\begin{SchemeCode}[emph={x,y}]
   > (amb-bind (amb 10 20) 
               (lambda (x) (amb-bind (amb 3 4 5)
                                (lambda (y) (amb (+ x y))))))
\end{SchemeCode}\vspace{-\medskipamount}
\REPLout{(13 14 15 23 24 25)}
Обратите внимание на то, каким образом с помощью \lmфункций с символами \lex{x} и \lex{y} связываются их возможные значения. Приведённая здесь цепочка вычислений соответстует \emph{стилю передачи продолжений} (CPS~--- continuation passing style). При этом строго задаётся последовательность вычислений, и каждая из вложенных \lmфункций содержит в себе информацию об оставшихся вычислениях. Такие функции называются \emph{продолжениями}.

Очевидно, что показанный нами способ вычислений универсален (на месте функций  \s{sqrt} и \s{+} могли оказаться любые другие функции), но он неудобен и громоздок. В таких случаях имеет смысл прибегнуть к помощи макропрограммирования и создать подходящую специальную форму, т.\,н. <<синтаксический сахар>>.

Определим форму \s{amb-do}, абстрагирующую связывание недетерминистических величин и произвольных функций:

\sfindex{amb-do}
\begin{Definition}[emph={x,A,res,B}]
(define-syntax amb-do
  (syntax-rules (<-) 
    [(amb-do (x <- A) res) (amb-bind A (lambda (x) res))]
    [(amb-do A B ___ res)  (amb-do A (amb-do B ___ res))]))
\end{Definition}

Здесь мы используем несколько более сложные приёмы макропрограммирования, чем прежде. Это связано с тем, что определяемая нами форма раскрывается рекурсивно, а поэтому требует рассмотрения нескольких вариантов. 

Разберёмся, как устроен этот макрос. Для представления синтаксических вариантов используется форма \sfi{syntax-rules}, в ней с помощью образцов описывается возможный синтаксис. Первый параметр этой формы \s{(<-)} указывает, что символ \s{<-} не требует определения и является ключевым (как, например, символ \s{else} в форме \s{cond}).
Третья строчка предписывает \emph{переписать} выражение вида \s{(amb-do (x <- A) res)} в соответствующее выражение, использующее \s{amb-bind}. Последняя строка показывает, как следует переписывать последовательность операторов в форме \s{amb-do} (образец последовательности {\schemestyle B ...} должен указываться не только в левой, но и в правой части макроса).

Вот как записываются приведённые нами выше примеры с помощью формы \s{amb-do}:

\begin{SchemeCode}
(amb-do  (x <- (amb 1 2 3))  (amb (sqr x)))
\end{SchemeCode}

\begin{SchemeCode}
(amb-do 
  (x <- (amb 10 20))
  (y <- (amb 3 4 5)) 
  (amb (+ x y)))
\end{SchemeCode}

Эту запись можно толковать так: с помощью оператора \s{<-} мы <<извлекаем>> по одному варианты из входных данных, именуем их, а~в~конце --- комбинируем с помощью тех или иных функций и~<<возвращаем>> результат обратно в коллекцию вариантов.

\section[2]{Поиск с возвратом}%
Нам удалось инкапсулировать полный перебор всех возможных вариантов. Теперь необходимо научиться накладывать ограничения.
Мы~уже видели, как с помощью выражения \s{(amb)} удалось исключить из рассмотрения отрицательные числа при вычислении квадратного корня. Условие в определении функции \s{n-sqrt} одновременно служит охраной от возникновения исключительной ситуации и обеспечивает отбрасывание нежелательных вариантов из возможных возвращаемых значений.

Абстракцией такой охраны будет служить функция \fun{assert}{p}:

\begin{Definition}[emph={p}]
  ; assert :: (A ... \arrow Bool) \arrow Amb(Any)
  (define (assert p) 
    (if p (amb null) (amb)))
\end{Definition}\newpage

Она устроена следующим образом. В случае невыполнения охраняющего условия \lex{p}, она возвращает  выражение \s{(amb)}~--- признак <<неудачи>>. Если же охраняющее условие выполняется, возвращается, вообще говоря, произвольное значение, в нашем случае~--- символ \s{null}, хотя на его месте могло быть всё, что угодно.

Каким же образом можно использовать эту странную функцию? Посмотрите на следующее выражение, записанное в CPS:

\begin{SchemeCode}[emph={x,y,z}]
(amb-bind (amb 1 2 3) 
          (lambda (x) 
            (amb-bind (assert (odd? x))
                      (lambda (y) 
                        (amb-bind (amb 10 20 30)
                                  (lambda (z) (amb (+ x z))))))))
\end{SchemeCode}

Сначала первое значение из \s{(amb 1 2 3)} будет связано с символом $x$. В этом случае выполнится охраняющее условие и функция \s{assert} вернёт выражение \s{(amb null)}. Символ \lex{y} будет связан со значением \s{null} и вычисления продолжатся, но, так как символ \lex{y} нигде в дальнейших вычислениях не используется, это никак не отразится на их результате.  Теперь понятно, почему совершенно неважно, что именно возвращает функция \s{assert} в случае успеха, однако, необходимо, чтобы возвращаемая величина могла быть связана с помощью \s{amb-bind}, и для этого она <<обёрнута>> конструктором~\s{amb}.

После того, как будут обработаны все варианты для величины~\lex{z}, вычисления обратятся к следующему значению \lex{x}. В этом случае \s{assert} вернёт \s{(amb)}, никакого связывания с \lex{y} вообще не произойдёт: выражение \s{(amb-bind (amb) (lambda (y) ...))} немедленно вернёт \s{(amb)}, продолжение \s{(lambda (y) ...)} ни разу не будет выполнено, а значит, не будет и перебора вариантов для \lex{z}. Полученное значение \s{(amb)} будет отброшено и вычислительный процесс перейдёт к очередному значению \lex{x}.

Таким образом, охраняющая функция \s{assert} не просто исключает нежелательные варианты из всех возможных значений ответа, но и избавляет от ненужных вычислений, отбрасывая соответствующие им продолжения. В рассмотренном нами примере, вместо девяти вычислений суммы, будет произведено только шесть~--- это столько, сколько существует решений для заданного ограничения.

Для того, чтобы функцию \s{assert} можно было включать в форму \s{amb-do}, следует добавить в её определение разбор ещё одного образца:\newpage

\begin{Definition}[emph={x,A,res,B}]
(define-syntax amb-do
  (syntax-rules (<-) 
    [(amb-do (x <- A) res) (amb-bind A (lambda (x) res))]
    [(amb-do A res)        (amb-bind A (lambda (_) res))]
    [(amb-do A B ___ res)  (amb-do A (amb-do B ___ res))]))
\end{Definition}

Добавленная строчка показывает, каким образом обрабатываются операторы, которые возвращают не используемые в дальнейшем значения. Здесь символ \s{_} играет роль произвольной переменной.

Вот как записывается с использованием формы \s{amb-do} разобранный нами пример:

\begin{SchemeCode}
(amb-do
  (x <- (amb 1 2 3))
  (assert (odd? x))
  (z <- (amb 10 20 30))
  (amb (+ x z)))
\end{SchemeCode}

Рассмотренный алгоритм перебора вариантов, удовлетворяющих некоему условию, исключающий часть вычислений, называется \emph{методом поиска в глубину с возвратом} (backtracking) или \emph{хронологическим поиском с возвратом}. Он позволяет существенно повысить эффективность алгоритмов систематического поиска.

\section[2]{Генерация множеств}%
Рассмотрим задачу получения множеств или списков с заданными свойствами. Допустим, нам необходимо получить множество квадратов чётных чисел, не превышающих $N$.  Вот как принято записывать определение для такого множества в математике:  $$\left\{ x^2~|~x \in {1, 2, ..., N};~~ x~mod~2 = 0 \right\}$$
А вот, как это же определение можно записать с помощью формы \s{amb-do}:
\begin{SchemeCode}[emph={x,N}]
  (amb-do
    (x <- (range N))
    (assert (even? x))
    (amb (sqr x)))
\end{SchemeCode}

Такой способ определения списков или множеств, полностью соответствующих их математическому описанию, называется \emph{генерацией} (\emph{list comprehension}) и используется во многих функциональных языках. Этот способ определения множеств будет для нас чрезвычайно полезен, поэтому ст\'{о}ит для удобства немного упростить его синтаксис, введя новую форму \sfi{collect} для генерации списков:

\begin{Definition}[emph={x,res}]
(define-syntax-rule (collect res x ...)
  (amb-do x ... (amb res)))
\end{Definition}
Теперь мы можем записать определение для множества квадратов чётных чисел, не превышающих $N$, совсем близко к традиционной записи:
\begin{SchemeCode}[emph={x,N}]
  (collect (sqr x) (x <- (range N)) (assert (even? x)))
\end{SchemeCode}

\section{Решение головоломок}%
Недетерминистическое программирование имеет широкое применение в самых разнообразных областях: в математике, при обработке текстов, в экспертных системах, в системах искуственного интеллекта и т.п. В качестве примеров и заданий мы рассмотрим задачи, которые принято относить к логическим и математическим головоломкам, чтобы с их помощью показать изящество и лаконичность недетерминистического подхода.

Рассмотрим следующую задачу. Имеется четыре списка слов:

\begin{itemize}
  \item \s{("the" "that" "a")}
  \item \s{("frog" "elephant" "thing" "turtle")}
  \item \s{("walked" "eats" "treaded" "grows")}
  \item \s{("slowly" "quickly" "salad")}
\end{itemize}

Необходимо найти, какие фразы можно составить, используя ровно по одному слову из всех этих списков, при двух условиях: 1) слова должны следовать в том же порядке, в котором указаны списки и 2) в каждой последовательной паре слов последняя буква первого слова должна совпадать с первой буквой второго. Например пара \s{"the"} и \s{"elephant"} удовлетворяют этому условию, а пара \s{"the"} и \s{"frog"} --- нет. 

Определим предикат \fun{joined?}{a b}, который определяет, связаны ли, согласно условию задачи, слова \lex{a} и \lex{b}:
\begin{SchemeCode}[emph={a,b}]
(define (joined? a b)
  (eq? (last (string->list a)) 
       (first (string->list b))))
\end{SchemeCode}

А теперь запишем условие задачи в терминах недетерминистических вычислений:

\begin{SchemeCode}[emph={w1,w2,w3,w4}]
> (collect (list w1 w2 w3 w4)
    (w1 <- (amb "the" "that" "a"))
    (w2 <- (amb "frog" "elephant" "thing" "turtle"))
    (assert (joined? w1 w2))
    (w3 <- (amb "walked" "eats" "treaded" "grows"))
    (assert (joined? w2 w3))
    (w4 <- (amb "slowly" "quickly" "salad"))
    (assert (joined? w3 w4)))%\smallskip%
%\outputstyle(("that"\ "thing"\ "grows"\ "slowly")%
 %\outputstyle("that"\ "thing"\ "grows"\ "salad")%
 %\outputstyle("that"\ "turtle"\ "eats"\ "slowly")%
 %\outputstyle("that"\ "turtle"\ "eats"\ "salad"))% 
\end{SchemeCode}

Обратите внимание на то, как расположены ограничения. Первый охраняющий оператор \s[emph={w1,w2}]{(assert (joined? w1 w2))} исключит перебор вариантов, не удовлетворяющих заданному условию. Таким образом, например, для слов \s{"the"} и \s{"frog"} третье слово подбираться не будет. Если бы мы сгруппировали охраняющие операторы по другому, скажем поместили бы их после определения списков слов, решение было бы точно таким же, изменилась бы только его эффективность: потребовалось бы рассмотреть $3\times4\times4\times3=144$ варианта. Поиск с возвратом находит решение, перебирая только $3\times4+3\times4+3\times3=33$ варианта.

Это любопытное замечание: порядок следования операторов корректной логической программы, как правило, не влияет на ответ; от порядка зависит только её эффективность.

Рассмотрим ещё одну классическую задачу. Фермер купил 100~голов скота на 100~долларов. Сколько каких животных он купил, если корова стоит 12~долларов, свинья --- 4~доллара, а овца --- 50~центов?

Приведём недетерминистическую программу, решающую эту задачу методом перебора:

\begin{SchemeCode}[emph={c,p,s}]
   > (collect `((,c cows) (,p pigs) (,s sheeps))
      (c <- (range 100/12))
      (p <- (range 100/4))
      (s <- (range 200))
      (assert (= 100 (+ c p s)))
      (assert (= 100 (+ (* c 12) (* p 4) (* s 1/2)))))
\end{SchemeCode}
\REPLout{(((1 cows) (11 pigs) (88 sheeps)))}

Здесь мы воспользовались тем, что недетерминистические величины представляются списками, таким образом, список натуральных чисел, возвращаемый функцией \s{range} годится в качестве множества возможных вариантов.

Эта задача, на первый взгляд, кажется чересчур простой для того, чтобы решать её методом перебора. Однако её аналитическое решение сводится к решению диофантового уравнения, и~оно вовсе не~тривиально. К~тому же, решений может быть несколько (например, если бы корова стоила 8~долларов, существовало бы шесть способов решить задачу, а~для цены в~11~долларов решений не~существует).

\begin{Assignment}
Решите следующие задачи:

\medskip
а) Пять школьниц написали экзаменационную работу и все получили разные оценки. Они решили, что каждая девочка должна сообщить домой о результатах экзамена и при этом сделать одно верное и
одно неверное утверждение. Вот соответствующие выдержки из их писем:
\begin{itemize}
  \item Бетти: «Китти была на экзамене второй, а я только третьей».
  \item Этель: «Вам будет приятно узнать, что я написала лучше всех. Второй была Джоан».
  \item Джоан: «Я была третьей, а бедная Этель последней».
  \item Китти: «Я оказалась второй. Мэри была только четвертой».
  \item Мэри: «Я была четвертой. Первое место заняла Бетти».
\end{itemize}
 В каком порядке на самом деле расположились отметки девочек?
 
 \medskip
 г)\label{as:rectangles} Какие стороны должен иметь прямоугольник, сложенный на плоскости из одинаковых кубиков так, чтобы число кубиков оказавшихся на его границе было равно числу внутренних кубиков? Решите эту же задачу для трёх измерений.

  \medskip
 в) Задача <<Сплетники>>: $A$ говорит, что $B$ отрицает, что $C$ считает, что $A$ всегда врёт, но в cвою очередь, $B$ рассказывает всем, что $A$ не склонен верить $C$. При этом $C$ уверяет, что слышал, как $A$ говорил о том, что $B$ считает $C$ лжецом. Выясните, кто из них говорит правду, а кто врёт.
 
 Для выражения отношения <<$x$ сказал, что $y$>>, используйте бинарный предикат \fun{says}{x y}, который возвращает истину, только тогда, когда $x$ и $y$ совпадают.

\medskip
 б) Как следует расставить знаки арифметических операций: $+, -, \times, /$ в выражении $$(((1~?~2)~?~3)~?~4)~?~5,$$ чтобы в результате получилось заданное число, например, $9$? Какие числа можно получить, если каждый знак может быть использован только один раз?
\end{Assignment}



\section{Логическое программирование}%
Логическими называют программы, представляющие собой набор утверждений или отношений между элементами перечислимых множеств. 

Приведём ряд простых примеров логических программ.

Функция \s{palindrom} определяет, является ли список палиндромным (одинаково читающимся как справа налево, так и в обратном порядке)

\begin{SchemeCode}[emph={x,y}]
(define palindrom?
  (/. '() --> #t
      `(,x) --> #t
      `(,x ,y ___ ,x) --> (palindrom? y)
      _ --> #f))
\end{SchemeCode}

Определяя эту функцию мы просто перечислили, в каких случаях список можно считать палиндромным: если он пуст или содержит единственный элемент, а так же, если его первый и последний элементы совпадают, а средняя часть является палиндромной. Во всех прочих случаях, согласно последней строчке определения, список палиндромным не является.

Ещё один пример: функция \fun{distinct}{x y ...} определяющая все ли её аргументы различны:

\begin{SchemeCode}
(define distinct
  (/. x x _ ___ --> #f
      x y z ___ --> (and (apply distinct x z)
                         (apply distinct y z))))
\end{SchemeCode}

Первая строчка гласит, что если первые два аргумента совпадают, то предикат возвращает \s{#f}. Вторая~--- что агрументы различны, если все они различны попарно.

Характерной особенностью логических программ является то, что все определяемые функции являются предикатами. Но это не означает, что такие программы позволяют получать только ответы <<да>> или <<нет>>. Пользуясь предикатами, как утверждениями, можно выводить новые отношения и получать информацию с помощью дедуктивного метода.

Рассмотрим следующий набор утверждений, касающий некоторой семьи:
Эндрю и Анна являются родителями Боба и Билла. Боб, в свою очередь, женившись на Бесси, родил Джесси и Джеймса. Вот как можно описать эти отношения:

\begin{Definition}
(define family '(Ann Andrew Bob Bill Bessy Jessy James))

(define mother
  (/. 'Ann 'Bob --> #t
      'Ann 'Bill --> #t
      'Bessy 'Jessy --> #t
      'Bessy 'James --> #t
      _ _ --> #f))

(define father
  (/. 'Andrew 'Bob --> #t
      'Andrew 'Bill --> #t
      'Bob 'Jessy --> #t
      'Bob 'James --> #t
      _ _ --> #f))
\end{Definition}
Эти предикаты можно рассматривать, как базу данных. Как мы можем извлечь информацию из этой базы? Можно задавать простые вопросы:
\REPL{(mother 'Ann 'Bob)}{#t}
\REPL{(mother 'Ann 'Chester)}{#f}
Но это не столь уж полезное применение. Попробуем выяснить, кто является матерью Джесси:

\begin{SchemeCode}[emph={x}]
   > (collect x
       (x <- family)
       (assert (mother x 'Jessy)))
\end{SchemeCode}
\REPLout{(Bessy)}

\newpage
А кому является отцом Эндрю?
\begin{SchemeCode}[emph={x}]
   > (collect x 
       (x <- family)
       (assert (father 'Andrew x)))
\end{SchemeCode}
\REPLout{(Bob Bill)}

Видно, что мы можем получать ответы на запросы к нашей базе. Оформим для удобства запрос в виде макроса:
  
\sfindex{?}
\begin{Definition}[emph={p,x,set}]
(define-syntax ?
  (syntax-rules (<-)
    [(? (x <- set) p) (collect x (x <- set) (assert p))]
    [(? (x <- set) ___ p) (collect (list x ___)
                            ( x <- set ) ___
                            (assert p))]))
\end{Definition}

Теперь можно обращаться к нашей базе таким образом:
\REPL{(? (x <- family) (mother x 'Jessy))}{(Bessy)}
\REPL{(? (x <- family) (father 'Andrew x))}{(Bob Bill)}
\REPL{(? (x <- family) (y <- family) (father x y))}
{((Andrew Bob) (Andrew Bill) (Bob Jessy) (Bob James))}

Характерно, что запросы работают симметрично. Мы можем выяснять, кто чей сын и кто чей отец, располагая одной и той же формой.

Определим теперь отношение <<родитель>> следующим образом:
\begin{Definition}[emph={x,y}]
(define (parent x y)
  (or (mother x y)
      (father x y)))
\end{Definition}
Теперь можно выяснить, кто является родителями Джесси:
\REPL{(? (x <- family) (parent x 'Jessy))}{(Bob Bessy)}

Следующим шагом будет определение отношения <<прародитель>>. Сформулируем его так: $x$ является прародителем $y$, если существует~$z$, такой что $x$~--- родитель $z$, и~$z$ --- родитель $y$. 

Для этого нам необходимо ввести квантор существования. Оформим его в виде макроса\footnote{Символ $\exists$ можно ввести в \Lang{DrRacket} следующим образом: набрать \s{\\exists} а потом нажать \MenuItem{Alt} + \s{\\}.}:

\sfindex{exists@$\exists$}
\begin{Definition}[emph={x,set,p}]
(define-syntax-rule ($\exists$ (x <- set) %...% p)
  (not (empty? (? (x <- set) %...% p)))) 
\end{Definition}

С его помощью запишем опредление для прародителя:
\begin{Definition}[emph={x,y,z}]
(define (grand-parent x y)
  ($\exists$ (z <- family) (and (parent x z)
                        (parent z y))))
\end{Definition}
\REPL{(? (x <- family) (grand-parent 'Ann x))}{(Jessy James)}
\REPL{(? (x <- family) (grand-parent x 'James))}{(Ann Andrew)}

Наконец, укажем кого можно считать предком:
\begin{Definition}[emph={x,y,z}]
(define (ancestor x y) 
  (or (parent x y)
      ($\exists$ (z <- family) (and (parent x z)
                            (ancestor z y)))))  
\end{Definition}

Выясним с его помощью является ли Эндрю предком Джесси:
\REPL{(? (x <- family) (ancestor 'Andrew 'Jessy))}{#t}
и кто является потомком Анны:
\REPL{(? (x <- family) (ancestor 'Ann x))}{(Bob Bill Jessy James)}

\begin{Assignment}
а)  Напишите определения для следующих отношений:
\begin{itemize}
  \item жена, муж, супруги;
  \item бабушка, дедушка,  внук;
  \item брат или сестра;
  \item тётя, дядя, племянник.
\end{itemize}

\medskip
б)  Дано, что в ориентированном графе вершины соединяются следующим образом: $A\to B$, $A\to C$, $B\to D$, $B\to E$, $D\to C$, $E\to C$. Найдите
\begin{itemize}
\item какие вершины достижимы из вершины $A$,
\item из каких вершин множно попасть в $E$,
\item какие вершины не связаны ни одним путём в графе.
\end{itemize}

\medskip
в) Для повышения эффективности логических программ, особенно использующих квантор существования, следовало бы сделать монаду \s{Amb} ленивой. Кроме того, ленивые вычисления позволили бы оперировать с потенциально бесконечными множествами и находить ответы для задач, в которых заранее не известно, сколько вариантов нужно рассмотреть, как, например в задаче про прямоугольники (\Asref[г]{as:rectangles}).

Что нужно изменить в определении монады для того, чтобы перебор и объединение вариантов стали ленивыми?
\end{Assignment}

\begin{Assignment}
Определите множество так называемых пифагоровых троек (египетских треугольников):
$$T = \left\{ [a~b~c]~|~a,b,c \in Z; a^2 + b^2 = c^2 \right\}$$
Описав это множество,
\begin{itemize}
  \item получите множество почти равнобедренных пифагоровых треугольников (таких, у которых длины двух сторон отличаются на единицу);
  \item получите множество примитивных пифагоровых треугольников, у которых все стороны взаимно просты;
  \item получите множество пар пифагоровых треугольников с одинаковой а) площадью, б) периметром в) стороной.
\end{itemize}
\end{Assignment}

\section[2]{Монады}%
Мы смогли организовать недетерминистические вычисления таким образом, что в самих  программах нигде явно не указывается процесс перебора и объединения вариантов. Всюду мы можем пользоваться стандарными функциями. Это стало возможным после того, как мы определили абстрактный полиморфный тип \s{Amb} и следующие операции:

\newpage
\begin{type}
  \s{amb ::} A ... \arrow Amb(A)
  \item \s{amb-bind ::} Amb(A) (A \arrow Amb(B)) \arrow Amb(B)
\end{type}
 
Они позволили нам построить абстракцию для таких чрезвычайно важных операций, как  аппликация функции, связывание величины с переменной и управление вычислительным потоком. По существу, мы оказались способны построить \emph{абстракцию вычислений} в самом широком смысле и на самом глубоком уровне. В наших руках оказался мощный инструмент, который называется \emph{монада}. 

\index{монада}Монадой называется тройка:
\begin{enumerate}
  \item Абстрактный полиморфный тип \Type{m};
  \item Единичная функция \Type{\s{return ::} A \arrow m(A)};
  \item Функция связывания \Type{\s{bind ::} m(A) (A \arrow m(B)) \arrow m(B)},
\end{enumerate}
для которых должны выполняться следующие соотношения:
\begin{SchemeCode}
  bind (return x) f = f x;
  bind x return = x;
  bind (bind x f) g = bind x (lambda (y) (bind (f y) g)).
\end{SchemeCode}
Первые два соотношения показывают, как работает единичная функция, а последнее~--- как организуется цепочка связываний.

Кроме того, для ряда монад можно определить <<нулевой>> элемент \s{mzero}, такой что:

\begin{SchemeCode}
  bind mzero f = bind x (lambda (y) mzero) = mzero
\end{SchemeCode}
\noindentи операцию сложения \s{mplus}, для которой \s{mzero} является нейтральным элементом.

В нашем случае, мы имеем монаду, определённую следующим образом\footnote{Построенная нами монада функционально эквивалентна монаде \s{List}, реализующей списки в языке \Lang{Haskel}.}:

\begin{SchemeCode}
  return = amb
  bind x f = foldr (nest mplus f) mzero x
  mplus = amb-append
  mzero = (amb)
\end{SchemeCode}

Что же позволяют делать монады? Во-первых они являются абстракцией вычислительного процесса и в этом смысле, позволяют определять различные парадигмы программирования. 

Во-вторых, любая монада позволяет использовать так называемую do-нотацию (в нашем случае, ей соответствует форма \s{amb-do}), которая является абстракцией последовательности операторов связывания и управления потоком вычислений с семантикой, задаваемой монадой.

Наконец, для любой монады с нулёвым элементом существует охраняющая функция:

\begin{SchemeCode}
  guard p = if p (return null) mzero
\end{SchemeCode}
в нашем случае, \s{guard = assert}.
Кроме неё, существует множество универсальных монадических функций, таких, как монадические свёртка и фильтрация, поднятие функций в монаду и т.п. которые определены и могут быть использованы для любых монад.

В функциональном программировании используется множество различных монад. С их помощью в рамках чистого ФП реализуются такие фундаментальные концепции, как последовательность вычислений и побочные эффекты (ввод-вывод, отладка, обработка исключений и т.п.), продолжения, объекты с изменяемым состоянием и объекты с общим доступом, оперирование коллекциями: списками, множествами, распределениями вероятностей и т.п.

\begin{Assignment}
Диалект \FLP предоставляет богатый инструментарий для определения и использования монад (см. справочное руководство по \FLP).

а) Определите монаду \Type{Amb} с помощью формы \s{define-monad-plus} и убедитесь, что монадические операторы и формы работают для неё корректно.

б) Используя функции для работы с множествами (см. \Asref{as:set}), определите монаду \Type{Set}, подобную монаде \Type{Amb}, но оперирующую вместо списков, множествами возможных значений. 

\end{Assignment}

\section[2]{Язык \Lang{Prolog}}%
Созданные нами формы и функции позволили реализовать некоторые из основных принципов логического программирования: поиск с возвратом, построение программ, как совокупности отношений и возможность решения, как <<прямых>>, так и <<обратных>> задач (так, определив отношение <<предок>>, мы смогли с его помощью найти потомков заданного человека). 

Однако за пределами нашего рассмотрения оказались другие важные механизмы логического программирования, например, унификация или неполные структуры данных. Они в полной мере представлены в таких языках, как \Lang{Prolog} или \Lang{Curry}.


Семантика языка \Lang{Prolog} близка к построенной нами модели недетерминистических вычислений, однако его синтаксис лучше приспособлен к особенностям логического программирования. Вот, например, как на языке \Lang{Datalog} (диалекте \Lang{Prolog}, входящем в \Lang{DrRacket}\footnote{Язык \Lang{Datalog} является языком запросов к базам данных и не в полной мере реализует парадигму логического программирования. Полноценным логическим языком, включённым в \Lang{DrRacket} является язык \Lang{Racklog} с синтаксисом \Scheme.}), формулируются семейные отношения из рассмотренного нами примера:


\begin{Definition}
  #lang datalog

  mother(ann, bob).
  mother(ann, bill).
  mother(bessy, jessy).
  mother(bessy, james).

  father(andrew, bob).
  father(andrew, bill).
  father(bob, jessy).
  father(bob, james).

  parent(X, Y) :- mother(X, Y).
  parent(X, Y) :- father(X, Y).

  grandparent(X, Y) :- parent(X, Z), parent(Z, Y).

  ancestor(X, Y) :- parent(X, Y),
  ancestor(X, Y) :- parent(X, Z), ancestor(Z, Y).
\end{Definition}

Запросы в \Lang{Datalog} оформляются таким образом:

\begin{SchemeCode}
  > mother(ann,A)?
  %\outputstyle mother(ann, bob).%
  %\outputstyle mother(ann, bill).\smallskip%
  > grandparent(X, jessy)?
  %\outputstyle grandparent(ann, jessy).%
  %\outputstyle grandparent(andrew, jessy).%
\end{SchemeCode}


Как видите, при определении отношений нам не приходится добавлять тривиальных утверждений о ложности всех неперечисленных случаев, нет необходимости явно задавать множество возможных значений и использовать квантор существования для вспомогательных переменных. Повторные определения выполняют роль дизъюнктов, а отношения, перечисляемые через запятую являются конъюнктами. Отношение  \s{$A$ :- $B$} означает, что $A$ является истинным, если $B$ является истинным.

Язык \Lang{Prolog} и его аналоги используется, как альтернатива и расширение \Lang{SQL} при работе с базами данных, для решения прикладных логических задач (составление расписаний, анализ текстов, построение экспертных систем и онтологий и т.п.)

\begin{Queeze}
 \item В чём состоит основное отличие традиционных и недетерминистических вычислений?
 \item В чём состоит принцип хронологического поиска с возвратом?
 \item Что такое монады и для чего они нужны? 
 \item Каким образом организуются логические программы?
\end{Queeze}
