5308
#hash(((def ((lib "formica/tools.rkt") andf)) . ((3925 . 4))) ((def ((lib "formica/arity.rkt") binary?)) . ((5628 . 3))) ((def ((lib "formica/tags.rkt") check-tag)) . ((5091 . 4))) ((def ((lib "formica/tools.rkt") fork)) . ((4054 . 7))) ((def ((lib "formica/tools.rkt") orf)) . ((3990 . 4))) ((def ((lib "formica/tools.rkt") id)) . ((3373 . 3))) ((form ((lib "formica/main.rkt") ->)) . ((2651 . 10))) ((form ((lib "formica/main.rkt") define/c)) . ((66 . 16))) ((form ((lib "formica/rewrite.rkt") /.)) . ((857 . 2))) ((def ((lib "formica/arity.rkt") inherit-arity)) . ((5817 . 3))) ((form ((lib "formica/memoize.rkt") define/memo)) . ((4881 . 3))) ((form ((lib "formica/main.rkt") formal)) . ((1644 . 2))) ((def ((lib "formica/main.rkt") all?)) . ((3110 . 7))) ((def ((lib "formica/tools.rkt") greedy)) . ((3635 . 3))) ((def ((lib "formica/tools.rkt") curry)) . ((4262 . 7))) ((def ((lib "formica/main.rkt") Sym)) . ((2075 . 2))) ((def ((lib "formica/tools.rkt") curried)) . ((4262 . 7))) ((def ((lib "formica/tools.rkt") flipped)) . ((3803 . 3))) ((form ((lib "formica/rewrite.rkt") rewrite-all)) . ((820 . 2))) ((def ((lib "formica/main.rkt") cons:)) . ((2464 . 4))) ((form ((lib "formica/rewrite.rkt") //.)) . ((1200 . 2))) ((def ((lib "formica/main.rkt") map)) . ((3035 . 4))) ((def ((lib "formica/main.rkt") formal-function?)) . ((1541 . 3))) ((form ((lib "formica/main.rkt") formal-out)) . ((1754 . 2))) ((def ((lib "formica/main.rkt") and/c)) . ((2347 . 3))) ((def ((lib "formica/arity.rkt") nullary?)) . ((5526 . 3))) ((form ((lib "formica/rewrite.rkt") rewrite-repeated)) . ((923 . 9))) ((def ((lib "formica/main.rkt") Real)) . ((1952 . 2))) ((def ((lib "formica/tools.rkt") function?)) . ((3324 . 3))) ((def ((lib "formica/tools.rkt") I3)) . ((3456 . 4))) ((form ((lib "formica/main.rkt") or)) . ((3250 . 2))) ((def ((lib "formica/main.rkt") any?)) . ((3110 . 7))) ((def ((lib "formica/main.rkt") n/f-list?)) . ((1666 . 5))) ((def ((lib "formica/tags.rkt") set-tag)) . ((5161 . 4))) ((def ((lib "formica/tags.rkt") tag?)) . ((5044 . 3))) ((def ((lib "formica/main.rkt") Any)) . ((2239 . 3))) ((def ((lib "formica/tools.rkt") -<)) . ((4054 . 7))) ((def ((lib "formica/arity.rkt") fixed-arity?)) . ((5364 . 3))) ((def ((lib "formica/tools.rkt") ¬)) . ((3726 . 5))) ((def ((lib "formica/tools.rkt") I2)) . ((3456 . 4))) ((form ((lib "formica/main.rkt") ==>)) . ((3297 . 2))) ((def ((lib "formica/main.rkt") formal?)) . ((1597 . 3))) ((def ((lib "formica/tools.rkt") I1)) . ((3456 . 4))) ((def ((lib "formica/main.rkt") +)) . ((2919 . 7))) ((def ((lib "formica/tags.rkt") tagged?)) . ((4994 . 3))) ((def ((lib "formica/tools.rkt") curryr)) . ((4430 . 7))) ((form ((lib "formica/rewrite.rkt") rewrite)) . ((652 . 6))) ((form ((lib "formica/rewrite.rkt") rewrite-all-repeated)) . ((1154 . 2))) ((def ((lib "formica/main.rkt") or/c)) . ((2287 . 3))) ((def ((lib "formica/tools.rkt") r-curried)) . ((4430 . 7))) ((def ((lib "formica/main.rkt") Str)) . ((2051 . 2))) ((form ((lib "formica/main.rkt") and)) . ((3273 . 2))) ((def ((lib "formica/tools.rkt") arg)) . ((3414 . 3))) ((form ((lib "formica/memoize.rkt") define/memo/c)) . ((4950 . 2))) ((def ((lib "formica/memoize.rkt") memoized)) . ((4779 . 3))) ((def ((lib "formica/tools.rkt") curried?)) . ((4601 . 3))) ((def ((lib "formica/main.rkt") not/c)) . ((2408 . 3))) ((def ((lib "formica/main.rkt") hold)) . ((1408 . 4))) ((def ((lib "formica/main.rkt") Int)) . ((1977 . 2))) ((def ((lib "formica/tools.rkt") fif)) . ((3849 . 5))) ((def ((lib "formica/arity.rkt") max-arity)) . ((5744 . 3))) ((def ((lib "formica/main.rkt") *)) . ((2919 . 7))) ((form ((lib "formica/main.rkt") ::)) . ((2890 . 2))) ((def ((lib "formica/tools.rkt") negated)) . ((3726 . 5))) ((def ((lib "formica/tools.rkt") composition)) . ((3554 . 3))) ((def ((lib "formica/arity.rkt") unary?)) . ((5578 . 3))) ((def ((lib "formica/main.rkt") Bool)) . ((1903 . 2))) ((def ((lib "formica/main.rkt") Index)) . ((2025 . 2))) ((def ((lib "formica/arity.rkt") variadic?)) . ((5420 . 3))) ((def ((lib "formica/tags.rkt") set-tag*)) . ((5264 . 4))) ((def ((lib "formica/tools.rkt") any-args)) . ((4215 . 3))) ((def ((lib "formica/tools.rkt") const)) . ((3510 . 3))) ((def ((lib "formica/arity.rkt") polyadic?)) . ((5473 . 3))) ((form ((lib "formica/main.rkt") is)) . ((1832 . 5))) ((def ((lib "formica/tools.rkt") all-args)) . ((4168 . 3))) ((def ((lib "formica/tools.rkt") >>)) . ((3680 . 3))) ((form ((lib "formica/rewrite.rkt") define//.)) . ((1229 . 2))) ((def ((lib "formica/main.rkt") Nat)) . ((2001 . 2))) ((def ((lib "formica/tools.rkt") fixed-point)) . ((4653 . 4))) ((form ((lib "formica/main.rkt") define-formal)) . ((1268 . 8))) ((def ((lib "formica/memoize.rkt") memoized?)) . ((4832 . 3))) ((def ((lib "formica/main.rkt") Fun)) . ((2099 . 2))) ((def ((lib "formica/arity.rkt") min-arity)) . ((5679 . 3))) ((def ((lib "formica/main.rkt") contract?)) . ((1783 . 3))) ((def ((lib "formica/main.rkt") n/f-pair?)) . ((1666 . 5))) ((def ((lib "formica/partial-app.rkt") apply)) . ((0 . 4))) ((def ((lib "formica/main.rkt") Num)) . ((1928 . 2))) ((def ((lib "formica/tools.rkt") ∘)) . ((3609 . 2))) ((form ((lib "formica/main.rkt") define-type)) . ((2123 . 6))) ((form ((lib "formica/rewrite.rkt") define/.)) . ((885 . 2))) ((form ((lib "formica/main.rkt") list:)) . ((2547 . 5))))
procedure
(apply f v ...) -> Any
  f : Fun
  v : Any
syntax
(define/c (f var ...) rhs)
 
rhs             = fun-constructor
                | (g args ...)
                | lit
                   
fun-constructor = (lambda arg-spec body)
                | (match-lambda arg-spec body)
                | (case-lambda arg-spec body)
                | (rewrite rules ...)
                | (rewrite-all rules ...)
                | (rewrite-repeated rules ...)
                | (rewrite-all-repeated rules ...)
                | (//. rules ...)
                | (/. rules ...)
syntax
(rewrite rule-spec ...)
 
rule-spec = (pat ... --> expr)
          | (pat ... --> (=> id) expr)
          | (pat ... --> (? guard) expr)
syntax
(rewrite-all rule-spec ...)
syntax
(/. rule-spec ...)
syntax
(define/. id rule-spec ...)
syntax
(rewrite-repeated rule-spec ...)
 
rule-spec = (pat ... ar expr)
          | (pat ... ar (=> id) expr)
          | (pat ... ar (? guard) expr)
             
ar        = -->
          | -->.
syntax
(rewrite-all-repeated rule-spec ...)
syntax
(//. rule-spec ...)
syntax
(define//. id rule-spec ...)
syntax
(define-formal f-spec ...)
 
f-spec = id
       | (id arity-spec)
 
  id : symbol?
  arity-spec : procedure-arity?
procedure
(hold f [arity]) -> formal-function?
  f : (or/c Fun Sym)
  arity : procedure-arity? = (arity-at-least 0)
procedure
(formal-function? x) -> Bool
  x : Any
procedure
(formal? x) -> Bool
  x : Any
syntax
(formal patt)
procedure
(n/f-pair? x) -> Bool
  x : Any
(n/f-list? x) -> Bool
  x : Any
syntax
(formal-out id ...)
procedure
(contract? v) -> Bool
  v : Any
syntax
(is v type-pred)
 
  v : Any
  type-pred : contract?
value
Bool : contract?
value
Num : contract?
value
Real : contract?
value
Int : contract?
value
Nat : contract?
value
Index : contract?
value
Str : contract?
value
Sym : contract?
value
Fun : contract?
syntax
(define-type name c ...)
(define-type (name x ...) c ...)
 
  c : contract?
  x : contract?
procedure
(Any v) -> contract?
  v : Any
procedure
(or/c c ...) -> contract?
  c : contract?
procedure
(and/c c ...) -> contract?
  c : contract?
procedure
(not/c c) -> contract?
  c : contract?
procedure
(cons: c1 c2) -> contract?
  c1 : contract?
  c2 : contract?
syntax
(list: c ...)
(list: c ..)
 
  c : contract?
syntax
(f: c ...)
 
  c : contract?
syntax
(-> dom ... range)
(-> dom ... rest .. range)
(-> dom ... (? opt ...) range)
(-> dom ... (? opt ...) rest .. range)
 
  dom : contract?
  range : contract?
  opt : contract?
  rest : contract?
syntax
(:: f sig fun-def)
procedure
(+ x y ...+) -> Num
  x : Num
  y : Num
(* x y ...+) -> Num
  x : Num
  y : Num
procedure
(map f lsts ...+) -> list?
  f : Fun
  lsts : list?
procedure
(all? f lsts ...+) -> Bool
  f : Fun
  lsts : list?
(any? f lsts ...+) -> Bool
  f : Fun
  lsts : list?
syntax
(or expr ...)
syntax
(and expr ...)
syntax
(==> expr1 expr2)
procedure
(function? x) -> Bool
  x : Any
procedure
(id x) -> Any
  x : Any
procedure
(arg n) -> Fun
  n : Ind
value
I1 : (arg 1)
I2 : (arg 2)
I3 : (arg 3)
procedure
(const x) -> Fun
  x : Any
procedure
(composition f ...) -> Fun
  f : Fun
value
∘ : composition
procedure
(greedy f) -> Fun
  f : Fun
procedure
(>> f ...) -> Fun
  f : Fun
procedure
(negated p) -> Fun
  p : Fun
(¬ p) -> Fun
  p : Fun
procedure
(flipped f) -> Fun
  f : Fun
procedure
(fif p f g) -> Fun
  p : Fun
  f : Fun
  g : Fun
procedure
(andf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(orf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(fork f g) -> Fun
  f : Fun
  g : unary?
(-< f g) -> Fun
  f : Fun
  g : unary?
procedure
(all-args p) -> Fun
  p : Fun
procedure
(any-args f) -> Fun
  f : Fun
procedure
(curry f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
(curried f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curryr f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
(r-curried f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curried? x) -> boolean?
  x : Any
procedure
(fixed-point f [#:same-test same?]) -> Fun
  f : Fun
  same? : (any/c any/c -> boolean?) = equal?
procedure
(memoized f) -> memoized?
  f : Fun
procedure
(memoized? f) -> Bool
  f : Fun
syntax
(define/memo (f var ...) body ...)
(define/memo f fun)
syntax
(define/memo/c (f var ...) body)
procedure
(tagged? f) -> tagged?
  f : Fun
procedure
(tag? f) -> Sym
  f : tagged?
procedure
(check-tag f t) -> Bool
  f : tagged?
  t : Any
procedure
(set-tag t [n]) -> (Fun -> tagged?)
  t : Sym
  n : (or/c symbol? #f) = #f
procedure
(set-tag* t [n]) -> (Fun -> Fun)
  t : Sym
  n : (or/c symbol? #f) = #f
procedure
(fixed-arity? f) -> boolean?
  f : Any
procedure
(variadic? f) -> boolean?
  f : Any
procedure
(polyadic? f) -> boolean?
  f : Any
procedure
(nullary? f) -> boolean?
  f : Any
procedure
(unary? f) -> boolean?
  f : Any
procedure
(binary? f) -> boolean?
  f : Any
procedure
(min-arity f) -> (or/c 0 positive?)
  f : Fun
procedure
(max-arity f) -> (or/c 0 positive? +inf.0)
  f : Fun
procedure
(inherit-arity f) -> (Fun -> Fun)
  f : Fun
