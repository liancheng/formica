7884
#hash(((def ((lib "formica/main.rkt") >=)) . ((3994 . 4))) ((def ((lib "formica/main.rkt") read)) . ((7910 . 2))) ((def ((lib "formica/main.rkt") Str)) . ((1161 . 2))) ((def ((lib "formica/main.rkt") -<)) . ((7617 . 2))) ((def ((lib "formica/main.rkt") symbol<?)) . ((3311 . 4))) ((def ((lib "formica/main.rkt") acos)) . ((4711 . 3))) ((form ((lib "formica/main.rkt") formal)) . ((2373 . 2))) ((def ((lib "formica/main.rkt") Bool)) . ((1013 . 2))) ((def ((lib "formica/main.rkt") curry)) . ((7685 . 4))) ((form ((lib "formica/main.rkt") or)) . ((143 . 2))) ((form ((lib "formica/main.rkt") define/c)) . ((628 . 5))) ((form ((lib "formica/main.rkt") define/.)) . ((6268 . 2))) ((def ((lib "formica/main.rkt") I3)) . ((7012 . 4))) ((form ((lib "formica/main.rkt") begin)) . ((0 . 2))) ((def ((lib "formica/main.rkt") equal?)) . ((2464 . 4))) ((def ((lib "formica/main.rkt") fork)) . ((7554 . 4))) ((def ((lib "formica/main.rkt") printf)) . ((8046 . 4))) ((def ((lib "formica/main.rkt") ordered?)) . ((2804 . 3))) ((def ((lib "formica/main.rkt") arg)) . ((6968 . 3))) ((def ((lib "formica/main.rkt") time)) . ((8248 . 3))) ((def ((lib "formica/main.rkt") +)) . ((3459 . 4))) ((def ((lib "formica/main.rkt") empty)) . ((5153 . 2))) ((def ((lib "formica/main.rkt") /)) . ((3630 . 3))) ((form ((lib "formica/main.rkt") define-formal)) . ((2038 . 5))) ((def ((lib "formica/main.rkt") memoized?)) . ((5986 . 3))) ((def ((lib "formica/main.rkt") cons)) . ((4797 . 4))) ((def ((lib "formica/main.rkt") pair?)) . ((4947 . 3))) ((def ((lib "formica/main.rkt") real-part)) . ((4360 . 3))) ((def ((lib "formica/main.rkt") I1)) . ((7012 . 4))) ((def ((lib "formica/main.rkt") displayln)) . ((7990 . 3))) ((def ((lib "formica/main.rkt") andf)) . ((7425 . 4))) ((def ((lib "formica/main.rkt") pair<?)) . ((3384 . 4))) ((def ((lib "formica/main.rkt") log)) . ((4458 . 3))) ((form ((lib "formica/main.rkt") provide)) . ((867 . 2))) ((def ((lib "formica/main.rkt") ≈)) . ((2701 . 2))) ((def ((lib "formica/main.rkt") empty?)) . ((5175 . 3))) ((def ((lib "formica/main.rkt") and/c)) . ((1457 . 3))) ((def ((lib "formica/main.rkt") null)) . ((4992 . 2))) ((def ((lib "formica/main.rkt") Index)) . ((1135 . 2))) ((def ((lib "formica/main.rkt") eq?)) . ((2395 . 4))) ((form ((lib "formica/main.rkt") define/memo)) . ((5840 . 3))) ((def ((lib "formica/main.rkt") asin)) . ((4668 . 3))) ((form ((lib "formica/main.rkt") is)) . ((942 . 5))) ((def ((lib "formica/main.rkt") <)) . ((3798 . 4))) ((def ((lib "formica/main.rkt") curried?)) . ((7862 . 3))) ((def ((lib "formica/main.rkt") range)) . ((5221 . 10))) ((form ((lib "formica/main.rkt") and)) . ((166 . 2))) ((def ((lib "formica/main.rkt") negative?)) . ((4110 . 3))) ((def ((lib "formica/main.rkt") filter)) . ((5689 . 4))) ((form ((lib "formica/main.rkt") λ)) . ((6651 . 6))) ((def ((lib "formica/main.rkt") ¬)) . ((7282 . 2))) ((def ((lib "formica/main.rkt") contract?)) . ((893 . 3))) ((def ((lib "formica/main.rkt") Real)) . ((1062 . 2))) ((def ((lib "formica/main.rkt") display)) . ((7936 . 3))) ((def ((lib "formica/main.rkt") ∘)) . ((7165 . 2))) ((def ((lib "formica/main.rkt") add-to-type-ordering)) . ((3032 . 7))) ((def ((lib "formica/main.rkt") cos)) . ((4584 . 3))) ((def ((lib "formica/main.rkt") formal-function?)) . ((2270 . 3))) ((def ((lib "formica/main.rkt") >)) . ((3929 . 4))) ((def ((lib "formica/main.rkt") const)) . ((7066 . 3))) ((form ((lib "formica/main.rkt") ->)) . ((1761 . 10))) ((def ((lib "formica/main.rkt") force)) . ((427 . 3))) ((def ((lib "formica/main.rkt") odd?)) . ((4267 . 3))) ((form ((lib "formica/main.rkt") define-syntax-rule)) . ((787 . 2))) ((form ((lib "formica/main.rkt") /.)) . ((6240 . 2))) ((def ((lib "formica/main.rkt") error)) . ((8162 . 4))) ((def ((lib "formica/main.rkt") cdr)) . ((4903 . 3))) ((form ((lib "formica/main.rkt") let)) . ((717 . 3))) ((def ((lib "formica/main.rkt") tolerance)) . ((2729 . 4))) ((def ((lib "formica/main.rkt") newline)) . ((8131 . 2))) ((def ((lib "formica/main.rkt") list)) . ((5058 . 3))) ((def ((lib "formica/main.rkt") sin)) . ((4542 . 3))) ((def ((lib "formica/main.rkt") id)) . ((6951 . 2))) ((def ((lib "formica/main.rkt") foldl)) . ((5598 . 5))) ((def ((lib "formica/main.rkt") *)) . ((3567 . 4))) ((def ((lib "formica/main.rkt") almost-equal?)) . ((2617 . 4))) ((def ((lib "formica/main.rkt") member)) . ((5771 . 4))) ((form ((lib "formica/main.rkt") delay)) . ((406 . 2))) ((def ((lib "formica/main.rkt") eval)) . ((292 . 6))) ((def ((lib "formica/main.rkt") expt)) . ((3675 . 4))) ((def ((lib "formica/main.rkt") Fun)) . ((1209 . 2))) ((def ((lib "formica/main.rkt") function?)) . ((6902 . 3))) ((def ((lib "formica/main.rkt") atan)) . ((4754 . 3))) ((def ((lib "formica/main.rkt") fif)) . ((7349 . 5))) ((def ((lib "formica/main.rkt") orf)) . ((7490 . 4))) ((form ((lib "formica/main.rkt") //.)) . ((6583 . 2))) ((form ((lib "formica/main.rkt") quasiquote)) . ((211 . 2))) ((def ((lib "formica/main.rkt") <=)) . ((3863 . 4))) ((form ((lib "formica/main.rkt") rewrite-all-repeated)) . ((6537 . 2))) ((def ((lib "formica/main.rkt") Sym)) . ((1185 . 2))) ((def ((lib "formica/main.rkt") different?)) . ((2536 . 4))) ((def ((lib "formica/main.rkt") memoized)) . ((5933 . 3))) ((form ((lib "formica/main.rkt") define-type)) . ((1233 . 6))) ((def ((lib "formica/main.rkt") formal?)) . ((2326 . 3))) ((def ((lib "formica/main.rkt") Nat)) . ((1111 . 2))) ((def ((lib "formica/main.rkt") type-ordering)) . ((2861 . 4))) ((def ((lib "formica/main.rkt") tan)) . ((4626 . 3))) ((form ((lib "formica/main.rkt") list:)) . ((1657 . 5))) ((def ((lib "formica/main.rkt") $)) . ((2253 . 2))) ((def ((lib "formica/main.rkt") curryr)) . ((7773 . 4))) ((def ((lib "formica/main.rkt") apply)) . ((6732 . 8))) ((def ((lib "formica/main.rkt") or/c)) . ((1397 . 3))) ((form ((lib "formica/main.rkt") cond)) . ((71 . 3))) ((def ((lib "formica/main.rkt") positive?)) . ((4060 . 3))) ((form ((lib "formica/main.rkt") quote)) . ((190 . 2))) ((def ((lib "formica/main.rkt") negated)) . ((7236 . 3))) ((def ((lib "formica/main.rkt") Num)) . ((1038 . 2))) ((def ((lib "formica/main.rkt") fixed-point)) . ((7635 . 3))) ((def ((lib "formica/main.rkt") composition)) . ((7110 . 3))) ((def ((lib "formica/main.rkt") null?)) . ((5013 . 3))) ((def ((lib "formica/main.rkt") modulo)) . ((4160 . 4))) ((form ((lib "formica/main.rkt") ::)) . ((2000 . 2))) ((def ((lib "formica/main.rkt") =)) . ((3735 . 4))) ((def ((lib "formica/main.rkt") abs)) . ((4311 . 3))) ((def ((lib "formica/main.rkt") map)) . ((5435 . 4))) ((def ((lib "formica/main.rkt") greedy)) . ((7191 . 3))) ((form ((lib "formica/main.rkt") rewrite-all)) . ((6203 . 2))) ((def ((lib "formica/main.rkt") car)) . ((4859 . 3))) ((form ((lib "formica/main.rkt") unquote)) . ((237 . 2))) ((def ((lib "formica/main.rkt") I2)) . ((7012 . 4))) ((def ((lib "formica/main.rkt") list?)) . ((5108 . 3))) ((def ((lib "formica/main.rkt") exp)) . ((4500 . 3))) ((form ((lib "formica/main.rkt") define//.)) . ((6612 . 2))) ((form ((lib "formica/main.rkt") rewrite)) . ((6035 . 6))) ((def ((lib "formica/main.rkt") foldr)) . ((5507 . 5))) ((def ((lib "formica/main.rkt") -)) . ((3522 . 3))) ((def ((lib "formica/main.rkt") even?)) . ((4222 . 3))) ((form ((lib "formica/main.rkt") define)) . ((476 . 5))) ((def ((lib "formica/main.rkt") Int)) . ((1087 . 2))) ((form ((lib "formica/main.rkt") unquote-splicing)) . ((260 . 2))) ((def ((lib "formica/main.rkt") flipped)) . ((7303 . 3))) ((form ((lib "formica/main.rkt") if)) . ((26 . 2))) ((def ((lib "formica/main.rkt") imag-part)) . ((4409 . 3))) ((def ((lib "formica/main.rkt") hold)) . ((2120 . 4))) ((def ((lib "formica/main.rkt") Any)) . ((1349 . 3))) ((form ((lib "formica/main.rkt") rewrite-repeated)) . ((6306 . 9))) ((def ((lib "formica/main.rkt") cons:)) . ((1574 . 4))) ((form ((lib "formica/main.rkt") require)) . ((839 . 2))) ((def ((lib "formica/main.rkt") not/c)) . ((1518 . 3))))
syntax
(begin expr ...)
syntax
(if test-expr then-expr else-expr)
syntax
(cond [test-expr res-expr] ...
      [else else-expr])
syntax
(or expr ...)
syntax
(and expr ...)
syntax
(quote expr)
syntax
(quasiquote expr)
syntax
(unquote expr)
syntax
(unquote-splicing expr)
procedure
(eval expr) -> any
  expr : Any
(eval expr ns) -> any
  expr : Any
  ns : namespace?
syntax
(delay expr)
procedure
(force x ...) -> Any
  x : Any
syntax
(define x body)
(define (f var ...) body ...)
(define (f var ... . rest) body ...)
(define ((f var1 ...) var2 ...) body ...)
syntax
(define/c (f var ...) rhs)
 
rhs = fun-constructor
    | (g args ...)
syntax
(let ([x expr] ...) body)
(let f ([x expr] ...) body)
syntax
(define-syntax-rule (form stx ...) expr)
syntax
(require name ...)
syntax
(provide id ...)
procedure
(contract? v) -> Bool
  v : Any
syntax
(is v type-pred)
 
  v : Any
  type-pred : contract?
value
Bool : contract?
value
Num : contract?
value
Real : contract?
value
Int : contract?
value
Nat : contract?
value
Index : contract?
value
Str : contract?
value
Sym : contract?
value
Fun : contract?
syntax
(define-type name c ...)
(define-type (name x ...) c ...)
 
  c : contract?
  x : contract?
procedure
(Any v) -> contract?
  v : Any
procedure
(or/c c ...) -> contract?
  c : contract?
procedure
(and/c c ...) -> contract?
  c : contract?
procedure
(not/c c) -> contract?
  c : contract?
procedure
(cons: c1 c2) -> contract?
  c1 : contract?
  c2 : contract?
syntax
(list: c ...)
(list: c ..)
 
  c : contract?
syntax
(f: c ...)
 
  c : contract?
syntax
(-> dom ... range)
(-> dom ... rest .. range)
(-> dom ... (? opt ...) range)
(-> dom ... (? opt ...) rest .. range)
 
  dom : contract?
  range : contract?
  opt : contract?
  rest : contract?
syntax
(:: f sig definitions ...)
syntax
(define-formal f-spec ...)
 
f-spec = id
       | (id arity-spec)
procedure
(hold f [arity]) -> formal-function?
  f : (or/c Fun Sym)
  arity : procedure-arity? = (arity-at-least 0)
alias
$ : hold
procedure
(formal-function? x) -> Bool
  x : Any
procedure
(formal? v) -> Bool
  v : Any
syntax
(formal patt)
procedure
(eq? v1 v2 ...) -> Bool
  v1 : Any
  v2 : Any
procedure
(equal? v1 v2 ...) -> Bool
  v1 : Any
  v2 : Any
procedure
(different? v1 v2 ...+) -> boolean?
  v1 : Any
  v2 : Any
procedure
(almost-equal? v1 v2 ...+) -> boolean?
  v1 : Any
  v2 : Any
value
≈ : almost-equal?
parameter
(tolerance) -> real?
(tolerance x) -> void?
  x : real?
procedure
(ordered? v ...) -> boolean?
  v : Any
parameter
(type-ordering) -> (list: (cons: contract? (Any Any -> Bool)))
(type-ordering p) -> void?
  p : (list: (cons: contract? (Any Any -> Bool)))
procedure
(add-to-type-ordering  type          
                      [prec-type     
                       ord-fun]) -> void?
  type : contract?
  prec-type : (or/c contract? 'last 'first) = 'last
  ord-fun : (Any Any -> Bool) = (cons #f)
procedure
(symbol<? s1 s2) -> boolean?
  s1 : Sym
  s2 : Sym
procedure
(pair<? p1 p2) -> boolean?
  p1 : pair?
  p2 : pair?
procedure
(+ x y ...+) -> Num
  x : Num
  y : Num
procedure
(- x ...) -> Num
  x : Num
procedure
(* x y ...+) -> Num
  x : Num
  y : Num
procedure
(/ x ...) -> Num
  x : Num
procedure
(expt x y) -> Num
  x : Num
  y : Num
procedure
(= x y ...) -> Bool
  x : Num
  y : Num
procedure
(< x y ...) -> Bool
  x : Real
  y : Real
procedure
(<= x y ...) -> Bool
  x : Real
  y : Real
procedure
(> x y ...) -> Bool
  x : Real
  y : Real
procedure
(>= x y ...) -> Bool
  x : Real
  y : Real
procedure
(positive? x) -> Bool
  x : Real
procedure
(negative? x) -> Bool
  x : Real
procedure
(modulo a b) -> Int
  a : Int
  b : Int
procedure
(even? a) -> Bool
  a : Int
procedure
(odd? a) -> Bool
  a : Int
procedure
(abs x) -> positive?
  x : Real
procedure
(real-part z) -> Real
  z : Num
procedure
(imag-part z) -> Real
  z : Num
procedure
(log z) -> Num
  z : Num
procedure
(exp z) -> Num
  z : Num
procedure
(sin z) -> Num
  z : Num
procedure
(cos z) -> Num
  z : Num
procedure
(tan z) -> Num
  z : Num
procedure
(asin z) -> Num
  z : Num
procedure
(acos z) -> Num
  z : Num
procedure
(atan z) -> Num
  z : Num
procedure
(cons a b) -> pair?
  a : Any
  b : Any
procedure
(car p) -> any
  p : pair?
procedure
(cdr p) -> any
  p : pair?
procedure
(pair? x) -> Bool
  x : Any
value
null : null?
procedure
(null? x) -> Bool
  x : Any
procedure
(list x ...) -> list?
  x : Any
procedure
(list? x) -> Bool
  x : Any
value
empty : null?
procedure
(empty? x) -> Bool
  x : Any
procedure
(range n) -> (listof Real)
  n : Real
(range n m) -> (list: Real ..)
  n : Real
  m : Real
(range n m step) -> (list: Real ..)
  n : Real
  m : Real
  step : Real
procedure
(map f lst ...) -> list?
  f : Fun
  lst : list?
procedure
(foldr f x0 lst ...) -> Any
  f : Fun
  x0 : Any
  lst : list?
procedure
(foldl f x0 lst ...) -> Any
  f : Fun
  x0 : Any
  lst : list?
procedure
(filter f lst) -> list?
  f : (Any -> Bool)
  lst : list?
procedure
(member v lst) -> Bool
  v : Any
  lst : list?
syntax
(define/memo (f var ...) body ...)
(define/memo f (λ (var ...) body ...))
procedure
(memoized f) -> memoized?
  f : Fun
procedure
(memoized? f) -> Bool
  f : Fun
syntax
(rewrite rule-spec ...)
 
rule-spec = (pat ... --> expr)
          | (pat ... --> (=> id) expr)
          | (pat ... --> (? guard) expr)
syntax
(rewrite-all rule-spec ...)
syntax
(/. rule-spec ...)
syntax
(define/. id rule-spec ...)
syntax
(rewrite-repeated rule-spec ...)
 
rule-spec = (pat ... ar expr)
          | (pat ... ar (=> id) expr)
          | (pat ... ar (? guard) expr)
             
ar        = -->
          | -->.
syntax
(rewrite-all-repeated rule-spec ...)
syntax
(//. rule-spec ...)
syntax
(define//. id rule-spec ...)
syntax
(λ vars body)
 
vars = (x ...)
     | (x ... . y)
     | x
procedure
(apply f arg-list) -> Any
  f : Fun
  arg-list : list?
(apply f arg ... arg-list) -> Any
  f : Fun
  arg : Any
  arg-list : list?
procedure
(function? x) -> Bool
  x : Any
value
id : Fun
procedure
(arg n) -> Fun
  n : Index
value
I1 : (arg 1)
I2 : (arg 2)
I3 : (arg 3)
procedure
(const x) -> Fun
  x : Any
procedure
(composition f ...) -> Fun
  f : Fun
alias
∘ : composition
procedure
(greedy f) -> Fun
  f : Fun
procedure
(negated p) -> Fun
  p : Fun
alias
¬ : negated
procedure
(flipped f) -> Fun
  f : Fun
procedure
(fif p f g) -> Fun
  p : Fun
  f : Fun
  g : Fun
procedure
(andf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(orf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(fork f g) -> Fun
  f : Fun
  g : unary?
alias
-< : fork
procedure
(fixed-point f) -> Fun
  f : Fun
procedure
(curry f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curryr f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curried? f) -> Bool
  f : Any
procedure
(read) -> any
procedure
(display expr) -> void?
  expr : Any
procedure
(displayln expr) -> void?
  expr : Any
procedure
(printf format expr ...) -> void?
  format : Str
  expr : Any
procedure
(newline) -> void?
procedure
(error message expr ...) -> void?
  message : Str
  expr : Any
procedure
(time expr) -> any
  expr : Any
