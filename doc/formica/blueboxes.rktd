8443
#hash(((form ((lib "formica/rewrite.rkt") define//.)) . ((1229 . 2))) ((form ((lib "formica/rewrite.rkt") //.)) . ((1200 . 2))) ((def ((lib "formica/main.rkt") n/f-list?)) . ((1683 . 5))) ((def ((lib "formica/main.rkt") using-monad)) . ((3947 . 4))) ((def ((lib "formica/main.rkt") Stream)) . ((6106 . 2))) ((def ((lib "formica/main.rkt") ordered?)) . ((7568 . 3))) ((def ((lib "formica/tools.rkt") curried)) . ((9098 . 7))) ((def ((lib "formica/types.rkt") Nat)) . ((2018 . 2))) ((form ((lib "formica/types.rkt") define-type)) . ((2140 . 6))) ((form ((lib "formica/main.rkt") do)) . ((4155 . 8))) ((def ((lib "formica/tools.rkt") composition)) . ((8430 . 3))) ((def ((lib "formica/main.rkt") guardf)) . ((4882 . 3))) ((def ((lib "formica/main.rkt") tagged?)) . ((9830 . 3))) ((def ((lib "formica/main.rkt") mzero)) . ((4602 . 2))) ((form ((lib "formica/main.rkt") bind)) . ((4077 . 5))) ((def ((lib "formica/main.rkt") add-to-type-ordering)) . ((7796 . 7))) ((def ((lib "formica/main.rkt") seq/m)) . ((4946 . 3))) ((form ((lib "formica/types.rkt") is)) . ((1849 . 5))) ((def ((lib "formica/main.rkt") fold/m)) . ((5080 . 5))) ((def ((lib "formica/main.rkt") ≈)) . ((7465 . 2))) ((def ((lib "formica/main.rkt") amb)) . ((6428 . 3))) ((def ((lib "formica/tools.rkt") binary?)) . ((10463 . 3))) ((form ((lib "formica/main.rkt") ==>)) . ((7041 . 2))) ((form ((lib "formica/main.rkt") formal-out)) . ((1771 . 2))) ((def ((lib "formica/main.rkt") zip)) . ((5863 . 3))) ((def ((lib "formica/main.rkt") Amb)) . ((6402 . 2))) ((def ((lib "formica/main.rkt") different?)) . ((7300 . 4))) ((form ((lib "formica/main.rkt") and)) . ((7017 . 2))) ((def ((lib "formica/main.rkt") listable?)) . ((5719 . 3))) ((def ((lib "formica/main.rkt") stream-take)) . ((6308 . 4))) ((def ((lib "formica/main.rkt") concat-map)) . ((6012 . 4))) ((def ((lib "formica/tools.rkt") r-curried)) . ((9266 . 7))) ((form ((lib "formica/main.rkt") collect)) . ((4331 . 8))) ((form ((lib "formica/memoize.rkt") define/memo/c)) . ((9786 . 2))) ((form ((lib "formica/types.rkt") ::)) . ((2907 . 2))) ((def ((lib "formica/tools.rkt") ∘)) . ((8485 . 2))) ((def ((lib "formica/tools.rkt") unary?)) . ((10413 . 3))) ((form ((lib "formica/main.rkt") scons)) . ((6381 . 2))) ((def ((lib "formica/main.rkt") n/f-pair?)) . ((1683 . 5))) ((def ((lib "formica/main.rkt") $)) . ((1541 . 2))) ((form ((lib "formica/main.rkt") using)) . ((4028 . 4))) ((def ((lib "formica/main.rkt") monad-plus?)) . ((3819 . 7))) ((def ((lib "formica/main.rkt") equal?)) . ((7068 . 7))) ((def ((lib "formica/main.rkt") pair<?)) . ((8125 . 4))) ((form ((lib "formica/types.rkt") list:)) . ((2564 . 5))) ((def ((lib "formica/types.rkt") Num)) . ((1945 . 2))) ((def ((lib "formica/tools.rkt") min-arity)) . ((10514 . 3))) ((def ((lib "formica/tools.rkt") I2)) . ((8332 . 4))) ((def ((lib "formica/tools.rkt") curry)) . ((9098 . 7))) ((def ((lib "formica/main.rkt") hold)) . ((1408 . 4))) ((def ((lib "formica/tools.rkt") flipped)) . ((8633 . 3))) ((def ((lib "formica/types.rkt") Bool)) . ((1920 . 2))) ((def ((lib "formica/main.rkt") amb-union)) . ((6481 . 4))) ((def ((lib "formica/main.rkt") stream-concat-map)) . ((6207 . 4))) ((def ((lib "formica/main.rkt") +)) . ((6663 . 7))) ((def ((lib "formica/tools.rkt") I3)) . ((8332 . 4))) ((def ((lib "formica/tools.rkt") curried?)) . ((9437 . 3))) ((def ((lib "formica/main.rkt") eval)) . ((7201 . 4))) ((def ((lib "formica/tools.rkt") any-args)) . ((9048 . 3))) ((def ((lib "formica/tools.rkt") -<)) . ((8884 . 7))) ((def ((lib "formica/types.rkt") Int)) . ((1994 . 2))) ((def ((lib "formica/main.rkt") Id)) . ((5340 . 2))) ((def ((lib "formica/memoize.rkt") memoized)) . ((9615 . 3))) ((def ((lib "formica/main.rkt") type-ordering)) . ((7625 . 4))) ((def ((lib "formica/main.rkt") symbol<?)) . ((8052 . 4))) ((def ((lib "formica/main.rkt") stream-concatenate)) . ((6135 . 3))) ((form ((lib "formica/main.rkt") define-monad)) . ((3432 . 17))) ((def ((lib "formica/tools.rkt") all-args)) . ((8998 . 3))) ((form ((lib "formica/rewrite.rkt") rewrite-all)) . ((820 . 2))) ((form ((lib "formica/rewrite.rkt") /.)) . ((857 . 2))) ((form ((lib "formica/rewrite.rkt") define/.)) . ((885 . 2))) ((def ((lib "formica/types.rkt") Sym)) . ((2092 . 2))) ((def ((lib "formica/tools.rkt") fif)) . ((8679 . 5))) ((form ((lib "formica/main.rkt") formal)) . ((1661 . 2))) ((def ((lib "formica/tools.rkt") function?)) . ((8200 . 3))) ((def ((lib "formica/main.rkt") tolerance)) . ((7493 . 4))) ((def ((lib "formica/main.rkt") monad?)) . ((3819 . 7))) ((def ((lib "formica/types.rkt") Any)) . ((2256 . 3))) ((def ((lib "formica/main.rkt") map/m)) . ((4996 . 4))) ((def ((lib "formica/main.rkt") List)) . ((5922 . 2))) ((def ((lib "formica/tools.rkt") ¬)) . ((8556 . 5))) ((def ((lib "formica/tools.rkt") greedy)) . ((8511 . 3))) ((def ((lib "formica/tools.rkt") fixed-arity?)) . ((10199 . 3))) ((def ((lib "formica/main.rkt") undefined)) . ((4519 . 2))) ((def ((lib "formica/main.rkt") formal-function?)) . ((1558 . 3))) ((def ((lib "formica/tools.rkt") fork)) . ((8884 . 7))) ((def ((lib "formica/main.rkt") all?)) . ((6854 . 7))) ((form ((lib "formica/types.rkt") ->)) . ((2668 . 10))) ((def ((lib "formica/types.rkt") cons:)) . ((2481 . 4))) ((def ((lib "formica/types.rkt") Index)) . ((2042 . 2))) ((def ((lib "formica/main.rkt") failure)) . ((4683 . 3))) ((def ((lib "formica/main.rkt") lift)) . ((4729 . 3))) ((def ((lib "formica/types.rkt") contract?)) . ((1800 . 3))) ((def ((lib "formica/types.rkt") not/c)) . ((2425 . 3))) ((def ((lib "formica/tools.rkt") max-arity)) . ((10579 . 3))) ((def ((lib "formica/tools.rkt") I1)) . ((8332 . 4))) ((def ((lib "formica/tools.rkt") curryr)) . ((9266 . 7))) ((def ((lib "formica/main.rkt") set-tag)) . ((9996 . 4))) ((def ((lib "formica/main.rkt") map)) . ((6779 . 4))) ((form ((lib "formica/rewrite.rkt") rewrite)) . ((652 . 6))) ((def ((lib "formica/main.rkt") amb-union-map)) . ((6566 . 4))) ((def ((lib "formica/types.rkt") Real)) . ((1969 . 2))) ((def ((lib "formica/tools.rkt") orf)) . ((8820 . 4))) ((def ((lib "formica/main.rkt") formal?)) . ((1614 . 3))) ((def ((lib "formica/main.rkt") Sequence)) . ((5360 . 8))) ((def ((lib "formica/main.rkt") sum/m)) . ((5290 . 3))) ((def ((lib "formica/main.rkt") monad)) . ((2936 . 13))) ((form ((lib "formica/tacit.rkt") define/c)) . ((66 . 16))) ((def ((lib "formica/tools.rkt") negated)) . ((8556 . 5))) ((def ((lib "formica/types.rkt") Fun)) . ((2116 . 2))) ((def ((lib "formica/tools.rkt") variadic?)) . ((10255 . 3))) ((form ((lib "formica/main.rkt") compose/m)) . ((4802 . 2))) ((def ((lib "formica/types.rkt") and/c)) . ((2364 . 3))) ((def ((lib "formica/main.rkt") check-tag)) . ((9926 . 4))) ((def ((lib "formica/tools.rkt") fixed-point)) . ((9489 . 4))) ((def ((lib "formica/main.rkt") mplus)) . ((4622 . 4))) ((form ((lib "formica/rewrite.rkt") rewrite-all-repeated)) . ((1154 . 2))) ((form ((lib "formica/rewrite.rkt") rewrite-repeated)) . ((923 . 9))) ((def ((lib "formica/types.rkt") or/c)) . ((2304 . 3))) ((def ((lib "formica/main.rkt") eq?)) . ((7068 . 7))) ((def ((lib "formica/main.rkt") concatenate)) . ((5949 . 3))) ((form ((lib "formica/main.rkt") or)) . ((6994 . 2))) ((form ((lib "formica/main.rkt") lift/m)) . ((4772 . 2))) ((def ((lib "formica/main.rkt") guard)) . ((4831 . 3))) ((def ((lib "formica/main.rkt") almost-equal?)) . ((7381 . 4))) ((def ((lib "formica/tools.rkt") nullary?)) . ((10361 . 3))) ((form ((lib "formica/memoize.rkt") define/memo)) . ((9717 . 3))) ((def ((lib "formica/tools.rkt") andf)) . ((8755 . 4))) ((def ((lib "formica/memoize.rkt") memoized?)) . ((9668 . 3))) ((def ((lib "formica/tools.rkt") polyadic?)) . ((10308 . 3))) ((def ((lib "formica/tools.rkt") arg)) . ((8290 . 3))) ((def ((lib "formica/types.rkt") Str)) . ((2068 . 2))) ((def ((lib "formica/main.rkt") monad-zero?)) . ((3819 . 7))) ((def ((lib "formica/tools.rkt") id)) . ((8249 . 3))) ((def ((lib "formica/main.rkt") filter/m)) . ((5184 . 5))) ((def ((lib "formica/main.rkt") any?)) . ((6854 . 7))) ((def ((lib "formica/main.rkt") mplus-map)) . ((5768 . 4))) ((form ((lib "formica/main.rkt") define-formal)) . ((1268 . 8))) ((def ((lib "formica/main.rkt") *)) . ((6663 . 7))) ((def ((lib "formica/partial-app.rkt") apply)) . ((0 . 4))) ((def ((lib "formica/main.rkt") tag)) . ((9880 . 3))) ((def ((lib "formica/tools.rkt") const)) . ((8386 . 3))) ((def ((lib "formica/main.rkt") return)) . ((4557 . 3))) ((def ((lib "formica/main.rkt") set-tag*)) . ((10099 . 4))))
procedure
(apply f v ...) -> Any
  f : Fun
  v : Any
syntax
(define/c (f var ...) rhs)
 
rhs             = fun-constructor
                | (g args ...)
                | lit
                   
fun-constructor = (lambda arg-spec body)
                | (match-lambda arg-spec body)
                | (case-lambda arg-spec body)
                | (rewrite rules ...)
                | (rewrite-all rules ...)
                | (rewrite-repeated rules ...)
                | (rewrite-all-repeated rules ...)
                | (//. rules ...)
                | (/. rules ...)
syntax
(rewrite rule-spec ...)
 
rule-spec = (pat ... --> expr)
          | (pat ... --> (=> id) expr)
          | (pat ... --> (? guard) expr)
syntax
(rewrite-all rule-spec ...)
syntax
(/. rule-spec ...)
syntax
(define/. id rule-spec ...)
syntax
(rewrite-repeated rule-spec ...)
 
rule-spec = (pat ... ar expr)
          | (pat ... ar (=> id) expr)
          | (pat ... ar (? guard) expr)
             
ar        = -->
          | -->.
syntax
(rewrite-all-repeated rule-spec ...)
syntax
(//. rule-spec ...)
syntax
(define//. id rule-spec ...)
syntax
(define-formal f-spec ...)
 
f-spec = id
       | (id arity-spec)
 
  id : symbol?
  arity-spec : procedure-arity?
procedure
(hold f [arity]) -> formal-function?
  f : (or/c Fun Sym)
  arity : procedure-arity? = (arity-at-least 0)
alias
$ : hold
procedure
(formal-function? x) -> Bool
  x : Any
procedure
(formal? x) -> Bool
  x : Any
syntax
(formal patt)
procedure
(n/f-pair? x) -> Bool
  x : Any
(n/f-list? x) -> Bool
  x : Any
syntax
(formal-out id ...)
procedure
(contract? v) -> Bool
  v : Any
syntax
(is v type-pred)
 
  v : Any
  type-pred : contract?
value
Bool : contract?
value
Num : contract?
value
Real : contract?
value
Int : contract?
value
Nat : contract?
value
Index : contract?
value
Str : contract?
value
Sym : contract?
value
Fun : contract?
syntax
(define-type name c ...)
(define-type (name x ...) c ...)
 
  c : contract?
  x : contract?
procedure
(Any v) -> contract?
  v : Any
procedure
(or/c c ...) -> contract?
  c : contract?
procedure
(and/c c ...) -> contract?
  c : contract?
procedure
(not/c c) -> contract?
  c : contract?
procedure
(cons: c1 c2) -> contract?
  c1 : contract?
  c2 : contract?
syntax
(list: c ...)
(list: c ..)
 
  c : contract?
syntax
(f: c ...)
 
  c : contract?
syntax
(-> dom ... range)
(-> dom ... rest .. range)
(-> dom ... (? opt ...) range)
(-> dom ... (? opt ...) rest .. range)
 
  dom : contract?
  range : contract?
  opt : contract?
  rest : contract?
syntax
(:: f sig fun-def)
procedure
(monad  #:return return         
        #:bind bind             
       [#:mzero mzero           
        #:mplus mplus           
        #:type type             
        #:failure failure]) -> monad?
  return : (Any → Any)
  bind : (Any (Any → Any) → Any)
  mzero : Any = 'undefined
  mplus : (Any Any → Any) = 'undefined
  type : contract? = #f
  failure : (Any → any) = raise-match-error
syntax
(define-monad id m-expr)
(define-monad id
  #:return return
  #:bind bind
  [#:mzero mzero]
  [#:mplus mplus]
  [#:type type]
  [#:failure failure])
 
  m-expr : monad?
  return : (Any → Any)
  bind : (Any (Any → Any) → Any)
  mzero : Any
  mplus : (Any Any → Any)
  type : contract?
  failure : (Any → Any)
procedure
(monad? v) -> Bool
  v : Any
(monad-zero? v) -> Bool
  v : Any
(monad-plus? v) -> Bool
  v : Any
parameter
(using-monad) -> monad?
(using-monad m) -> void?
  m : monad?
syntax
(using m expr ...)
 
  m : monad?
syntax
(bind m <arr> f [ <arr> fs ...])
 
<arr> = >>=
      | >>
syntax
(do ops ...+ res)
 
ops = (pat <- expr)
    | (pat <-: expr)
    | ((pat1 pat2 ...) <<- expr)
    | ((pat1 pat2 ...) <<-: expr)
    | expr
syntax
(collect expr ops ...+)
 
ops = (pat <- expr)
    | (pat <-: expr)
    | ((pat1 pat2 ...) <<- expr)
    | ((pat1 pat2 ...) <<-: expr)
    | guard-expr
procedure
(undefined) -> undefined?
procedure
(return x) -> any
  x : Any
value
mzero : Any
procedure
(mplus x y) -> Any
  x : Any
  y : Any
procedure
(failure v) -> any
  v : Any
procedure
(lift f) -> Fun
  f : Fun
syntax
(lift/m f arg ...+)
syntax
(compose/m fs ...+)
procedure
(guard test) -> Any
  test : Bool
procedure
(guardf pred) -> any
  pred : (Any --> Bool)
procedure
(seq/m lst) -> Any
  lst : list?
procedure
(map/m f lst) -> Any
  f : (Any Any → Any)
  lst : list?
procedure
(fold/m f x0 lst) -> Any
  f : (Any Any → Any)
  x0 : Any
  lst : list?
procedure
(filter/m f x0 lst) -> Any
  f : (Any Any → Any)
  x0 : Any
  lst : list?
procedure
(sum/m lst) -> Any
  lst : list?
value
Id : monad?
procedure
(Sequence  #:return ret               
           #:mplus seq-append         
          [#:map seq-append-map]) -> monad-plus?
  ret : (Any ... → listable?)
  seq-append : (listable? listable? → listable?)
  seq-append-map : ((Any → listable?) listable? → listable?)
                 = mplus-map
procedure
(listable? v) -> Bool
  v : Any
procedure
(mplus-map f s) -> listable?
  f : (Any → listable?)
  s : listable?
procedure
(zip s ...) -> sequence?
  s : listable?
value
List : monad-plus?
procedure
(concatenate s ...) -> list?
  s : listable?
procedure
(concat-map f s) -> list?
  f : (any/c → n/f-list?)
  s : listable?
value
Stream : monad-plus?
procedure
(stream-concatenate s ...) -> stream?
  s : listable?
procedure
(stream-concat-map f s) -> stream?
  f : (any/c → stream?)
  s : listable?
procedure
(stream-take s n) -> list?
  s : stream?
  n : Nat
syntax
(scons h t)
value
Amb : monad-plus?
procedure
(amb v ...) -> stream?
  v : any/c
procedure
(amb-union s1 s2) -> stream?
  s1 : listable?
  s2 : listable?
procedure
(amb-union-map f s) -> stream?
  f : (any/c → stream?)
  s : listable?
procedure
(+ x y ...+) -> Num
  x : Num
  y : Num
(* x y ...+) -> Num
  x : Num
  y : Num
procedure
(map f lsts ...+) -> list?
  f : Fun
  lsts : list?
procedure
(all? f lsts ...+) -> Bool
  f : Fun
  lsts : list?
(any? f lsts ...+) -> Bool
  f : Fun
  lsts : list?
syntax
(or expr ...)
syntax
(and expr ...)
syntax
(==> expr1 expr2)
procedure
(eq? x y ...+) -> boolean?
  x : Any
  y : Any
(equal? x y ...+) -> boolean?
  x : Any
  y : Any
procedure
(eval expr [ns]) -> any
  expr : Any
  ns : namespace? = formica-namespace
procedure
(different? v1 v2 ...+) -> boolean?
  v1 : Any
  v2 : Any
procedure
(almost-equal? v1 v2 ...+) -> boolean?
  v1 : Any
  v2 : Any
value
≈ : almost-equal?
parameter
(tolerance) -> real?
(tolerance x) -> void?
  x : real?
procedure
(ordered? v ...) -> boolean?
  v : Any
parameter
(type-ordering) -> (list: (cons: contract? (Any Any -> Bool)))
(type-ordering p) -> void?
  p : (list: (cons: contract? (Any Any -> Bool)))
procedure
(add-to-type-ordering  type          
                      [prec-type     
                       ord-fun]) -> void?
  type : contract?
  prec-type : contract? = 'last
  ord-fun : (Any Any -> Bool) = (cons #f)
procedure
(symbol<? s1 s2) -> boolean?
  s1 : Sym
  s2 : Sym
procedure
(pair<? p1 p2) -> boolean?
  p1 : pair?
  p2 : pair?
procedure
(function? x) -> Bool
  x : Any
procedure
(id x) -> Any
  x : Any
procedure
(arg n) -> Fun
  n : Ind
value
I1 : (arg 1)
I2 : (arg 2)
I3 : (arg 3)
procedure
(const x) -> Fun
  x : Any
procedure
(composition f ...) -> Fun
  f : Fun
value
∘ : composition
procedure
(greedy f) -> Fun
  f : Fun
procedure
(negated p) -> Fun
  p : Fun
(¬ p) -> Fun
  p : Fun
procedure
(flipped f) -> Fun
  f : Fun
procedure
(fif p f g) -> Fun
  p : Fun
  f : Fun
  g : Fun
procedure
(andf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(orf f g ...) -> Fun
  f : Fun
  g : Fun
procedure
(fork f g) -> Fun
  f : Fun
  g : unary?
(-< f g) -> Fun
  f : Fun
  g : unary?
procedure
(all-args p) -> Fun
  p : unary?
procedure
(any-args f) -> Fun
  f : unary?
procedure
(curry f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
(curried f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curryr f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
(r-curried f arg ...) -> (or/c curried? Any)
  f : Fun
  arg : Any
procedure
(curried? x) -> boolean?
  x : Any
procedure
(fixed-point f [#:same-test same?]) -> Fun
  f : Fun
  same? : (any/c any/c -> boolean?) = equal?
procedure
(memoized f) -> memoized?
  f : Fun
procedure
(memoized? f) -> Bool
  f : Fun
syntax
(define/memo (f var ...) body ...)
(define/memo f fun)
syntax
(define/memo/c (f var ...) body)
procedure
(tagged? f) -> tagged?
  f : Fun
procedure
(tag f) -> Sym
  f : tagged?
procedure
(check-tag f t) -> Bool
  f : tagged?
  t : Any
procedure
(set-tag t [n]) -> (Fun -> tagged?)
  t : Sym
  n : (or/c symbol? #f) = #f
procedure
(set-tag* t [n]) -> (Fun -> Fun)
  t : Sym
  n : (or/c symbol? #f) = #f
procedure
(fixed-arity? v) -> boolean?
  v : Any
procedure
(variadic? v) -> boolean?
  v : Any
procedure
(polyadic? v) -> boolean?
  v : Any
procedure
(nullary? v) -> boolean?
  v : Any
procedure
(unary? v) -> boolean?
  v : Any
procedure
(binary? f) -> boolean?
  f : Any
procedure
(min-arity f) -> (or/c 0 positive?)
  f : Fun
procedure
(max-arity f) -> (or/c 0 positive? +inf.0)
  f : Fun
